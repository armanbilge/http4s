<html>
      <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title id="title">
          org/http4s/multipart/MultipartParser.scala.html
        </title>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.20.1/css/theme.default.min.css" type="text/css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.20.1/js/jquery.tablesorter.min.js"></script><link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css" type="text/css"/><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script><script type="text/javascript">
        $(document).ready(function() {$(".tablesorter").tablesorter();});
      </script>
        <style>
          table.codegrid { font-family: monospace; font-size: 12px; width: auto!important; }table.statementlist { width: auto!important; font-size: 13px; } table.codegrid td { padding: 0!important; border: 0!important } table td.linenumber { width: 40px!important; } 
        </style>
      </head>
      <body style="font-family: monospace;">
        <ul class="nav nav-tabs">
          <li>
            <a href="#codegrid" data-toggle="tab">Codegrid</a>
          </li>
          <li>
            <a href="#statementlist" data-toggle="tab">Statement List</a>
          </li>
        </ul>
        <div class="tab-content">
          <div class="tab-pane active" id="codegrid">
            <pre style='font-size: 12pt; font-family: courier, monospace;'>1 <span style=''>/*
</span>2 <span style=''> * Copyright 2013 http4s.org
</span>3 <span style=''> *
</span>4 <span style=''> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
</span>5 <span style=''> * you may not use this file except in compliance with the License.
</span>6 <span style=''> * You may obtain a copy of the License at
</span>7 <span style=''> *
</span>8 <span style=''> *     http://www.apache.org/licenses/LICENSE-2.0
</span>9 <span style=''> *
</span>10 <span style=''> * Unless required by applicable law or agreed to in writing, software
</span>11 <span style=''> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
</span>12 <span style=''> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</span>13 <span style=''> * See the License for the specific language governing permissions and
</span>14 <span style=''> * limitations under the License.
</span>15 <span style=''> */
</span>16 <span style=''>
</span>17 <span style=''>package org.http4s
</span>18 <span style=''>package multipart
</span>19 <span style=''>
</span>20 <span style=''>import cats.effect.Concurrent
</span>21 <span style=''>import cats.effect.Resource
</span>22 <span style=''>import cats.effect.std.Supervisor
</span>23 <span style=''>import cats.syntax.all._
</span>24 <span style=''>import fs2.Chunk
</span>25 <span style=''>import fs2.Pipe
</span>26 <span style=''>import fs2.Pull
</span>27 <span style=''>import fs2.Pure
</span>28 <span style=''>import fs2.RaiseThrowable
</span>29 <span style=''>import fs2.Stream
</span>30 <span style=''>import fs2.io.file.Files
</span>31 <span style=''>import fs2.io.file.Flags
</span>32 <span style=''>import fs2.io.file.Path
</span>33 <span style=''>import org.http4s.internal.bug
</span>34 <span style=''>import org.typelevel.ci.CIString
</span>35 <span style=''>
</span>36 <span style=''>/** A low-level multipart-parsing pipe.  Most end users will prefer EntityDecoder[Multipart]. */
</span>37 <span style=''>object MultipartParser {
</span>38 <span style=''>  private[this] val CRLFBytesN = </span><span style='background: #AEF1AE'>Array[Byte]('\r', '\n')</span><span style=''>
</span>39 <span style=''>  private[this] val DoubleCRLFBytesN = </span><span style='background: #AEF1AE'>Array[Byte]('\r', '\n', '\r', '\n')</span><span style=''>
</span>40 <span style=''>  private[this] val DashDashBytesN = </span><span style='background: #AEF1AE'>Array[Byte]('-', '-')</span><span style=''>
</span>41 <span style=''>  private[this] val BoundaryBytesN: Boundary =&gt; Array[Byte] = boundary =&gt;
</span>42 <span style=''>    </span><span style='background: #AEF1AE'>boundary.value.getBytes(&quot;UTF-8&quot;)</span><span style=''>
</span>43 <span style=''>  val StartLineBytesN: Boundary =&gt; Array[Byte] = </span><span style='background: #AEF1AE'>BoundaryBytesN.andThen(DashDashBytesN ++ _)</span><span style=''>
</span>44 <span style=''>
</span>45 <span style=''>  /** `delimiter` in RFC 2046 */
</span>46 <span style=''>  private[this] val ExpectedBytesN: Boundary =&gt; Array[Byte] =
</span>47 <span style=''>    </span><span style='background: #AEF1AE'>BoundaryBytesN.andThen(CRLFBytesN ++ DashDashBytesN ++ _)</span><span style=''>
</span>48 <span style=''>  private[this] val dashByte: Byte = </span><span style='background: #AEF1AE'>'-'.toByte</span><span style=''>
</span>49 <span style=''>  private[this] val streamEmpty = </span><span style='background: #AEF1AE'>Stream.empty</span><span style=''>
</span>50 <span style=''>
</span>51 <span style=''>  private type SplitStream[F[_]] = Pull[F, Nothing, (Stream[F, Byte], Stream[F, Byte])]
</span>52 <span style=''>
</span>53 <span style=''>  private[this] sealed trait Event
</span>54 <span style=''>  private[this] final case class PartStart(value: Headers) extends Event
</span>55 <span style=''>  private[this] final case class PartChunk(value: Chunk[Byte]) extends Event
</span>56 <span style=''>  private[this] case object PartEnd extends Event
</span>57 <span style=''>
</span>58 <span style=''>  def parseStreamed[F[_]: Concurrent](
</span>59 <span style=''>      boundary: Boundary,
</span>60 <span style=''>      limit: Int = 1024,
</span>61 <span style=''>  ): Pipe[F, Byte, Multipart[F]] = { st =&gt;
</span>62 <span style=''>    </span><span style='background: #AEF1AE'>st.through(
</span>63 <span style=''></span><span style='background: #AEF1AE'>      parseToPartsStream(boundary, limit)
</span>64 <span style=''></span><span style='background: #AEF1AE'>    ).fold(Vector.empty[Part[F]])(_ :+ _)
</span>65 <span style=''></span><span style='background: #AEF1AE'>      .map(Multipart(_, boundary))</span><span style=''>
</span>66 <span style=''>  }
</span>67 <span style=''>
</span>68 <span style=''>  def parseToPartsStream[F[_]](boundary: Boundary, limit: Int = 1024)(implicit
</span>69 <span style=''>      F: Concurrent[F]
</span>70 <span style=''>  ): Pipe[F, Byte, Part[F]] = { st =&gt;
</span>71 <span style=''>    </span><span style='background: #AEF1AE'>st.through(
</span>72 <span style=''></span><span style='background: #AEF1AE'>      parseEvents[F](boundary, limit)
</span>73 <span style=''></span><span style='background: #AEF1AE'>    )
</span>74 <span style=''></span><span style='background: #AEF1AE'>      // The left half is the part under construction, the right half is a part to be emitted.
</span>75 <span style=''></span><span style='background: #AEF1AE'>      .evalMapAccumulate[F, Option[Part[F]], Option[Part[F]]](None) { (acc, item) =&gt;
</span>76 <span style=''></span><span style='background: #AEF1AE'>        (acc, item) match {
</span>77 <span style=''></span><span style='background: #AEF1AE'>          case (None, PartStart(headers)) =&gt;
</span>78 <span style=''></span><span style='background: #AEF1AE'>            F.pure((Some(Part(headers, Stream.empty)), None))
</span>79 <span style=''></span><span style='background: #AEF1AE'>          // Shouldn't happen if the `parseToEventsStream` contract holds.
</span>80 <span style=''></span><span style='background: #AEF1AE'>          case (None, _: PartChunk | PartEnd) =&gt;
</span>81 <span style=''></span><span style='background: #AEF1AE'>            </span><span style='background: #F0ADAD'>F.raiseError(bug(&quot;Missing PartStart&quot;))</span><span style='background: #AEF1AE'>
</span>82 <span style=''></span><span style='background: #AEF1AE'>          case (Some(acc0), PartChunk(chunk)) =&gt;
</span>83 <span style=''></span><span style='background: #AEF1AE'>            F.pure((Some(acc0.copy(body = acc0.body ++ Stream.chunk(chunk))), None))
</span>84 <span style=''></span><span style='background: #AEF1AE'>          case (Some(_), PartEnd) =&gt;
</span>85 <span style=''></span><span style='background: #AEF1AE'>            // Part done - emit it and start over.
</span>86 <span style=''></span><span style='background: #AEF1AE'>            F.pure((None, acc))
</span>87 <span style=''></span><span style='background: #AEF1AE'>          // Shouldn't happen if the `parseToEventsStream` contract holds.
</span>88 <span style=''></span><span style='background: #AEF1AE'>          case (Some(_), _: PartStart) =&gt;
</span>89 <span style=''></span><span style='background: #AEF1AE'>            </span><span style='background: #F0ADAD'>F.raiseError(bug(&quot;Missing PartEnd&quot;))</span><span style='background: #AEF1AE'>
</span>90 <span style=''></span><span style='background: #AEF1AE'>        }
</span>91 <span style=''></span><span style='background: #AEF1AE'>      }
</span>92 <span style=''></span><span style='background: #AEF1AE'>      .mapFilter(_._2)</span><span style=''>
</span>93 <span style=''>  }
</span>94 <span style=''>
</span>95 <span style=''>  private def splitAndIgnorePrev[F[_]](
</span>96 <span style=''>      values: Array[Byte],
</span>97 <span style=''>      state: Int,
</span>98 <span style=''>      c: Chunk[Byte],
</span>99 <span style=''>  ): (Int, Stream[F, Byte]) = {
</span>100 <span style=''>    var i = </span><span style='background: #AEF1AE'>0</span><span style=''>
</span>101 <span style=''>    var currState = state
</span>102 <span style=''>    val len = </span><span style='background: #AEF1AE'>values.length</span><span style=''>
</span>103 <span style=''>    while (</span><span style='background: #AEF1AE'>currState &lt; len &amp;&amp; i &lt; c.size</span><span style=''>) </span><span style='background: #AEF1AE'>{
</span>104 <span style=''></span><span style='background: #AEF1AE'>      if (c(i) == values(currState))
</span>105 <span style=''></span><span style='background: #AEF1AE'>        currState += 1
</span>106 <span style=''></span><span style='background: #AEF1AE'>      else if (c(i) == values(0))
</span>107 <span style=''></span><span style='background: #AEF1AE'>        </span><span style='background: #F0ADAD'>currState = 1</span><span style='background: #AEF1AE'>
</span>108 <span style=''></span><span style='background: #AEF1AE'>      else
</span>109 <span style=''></span><span style='background: #AEF1AE'>        currState = 0
</span>110 <span style=''></span><span style='background: #AEF1AE'>      i += 1
</span>111 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>112 <span style=''>
</span>113 <span style=''>    if (</span><span style='background: #AEF1AE'>currState == 0</span><span style=''>)
</span>114 <span style=''>      </span><span style='background: #AEF1AE'>(0, Stream.empty)</span><span style=''>
</span>115 <span style=''>    else </span><span style='background: #AEF1AE'>if (currState == len)
</span>116 <span style=''></span><span style='background: #AEF1AE'>      (currState, Stream.chunk(c.drop(i)))
</span>117 <span style=''></span><span style='background: #AEF1AE'>    else
</span>118 <span style=''></span><span style='background: #AEF1AE'>      (currState, Stream.empty)</span><span style=''>
</span>119 <span style=''>  }
</span>120 <span style=''>
</span>121 <span style=''>  /** Split a chunk in the case of a complete match:
</span>122 <span style=''>    *
</span>123 <span style=''>    * If it is a chunk that is between a partial match
</span>124 <span style=''>    * (middleChunked), consider the prior partial match
</span>125 <span style=''>    * as part of the data to emit.
</span>126 <span style=''>    *
</span>127 <span style=''>    * If it is a fully matched, fresh chunk (no carry over partial match),
</span>128 <span style=''>    * emit everything until the match, and everything after the match.
</span>129 <span style=''>    *
</span>130 <span style=''>    * If it is the continuation of a partial match,
</span>131 <span style=''>    * emit everything after the partial match.
</span>132 <span style=''>    */
</span>133 <span style=''>  private def splitCompleteMatch[F[_]](
</span>134 <span style=''>      middleChunked: Boolean,
</span>135 <span style=''>      sti: Int,
</span>136 <span style=''>      i: Int,
</span>137 <span style=''>      acc: Stream[F, Byte],
</span>138 <span style=''>      carry: Stream[F, Byte],
</span>139 <span style=''>      c: Chunk[Byte],
</span>140 <span style=''>  ): (Int, Stream[F, Byte], Stream[F, Byte]) =
</span>141 <span style=''>    if (middleChunked)
</span>142 <span style=''>      </span><span style='background: #AEF1AE'>(
</span>143 <span style=''></span><span style='background: #AEF1AE'>        sti,
</span>144 <span style=''></span><span style='background: #AEF1AE'>        // Emit the partial match as well
</span>145 <span style=''></span><span style='background: #AEF1AE'>        acc ++ carry ++ Stream.chunk(c.take(i - sti)),
</span>146 <span style=''></span><span style='background: #AEF1AE'>        Stream.chunk(c.drop(i)),
</span>147 <span style=''></span><span style='background: #AEF1AE'>      )</span><span style=''> // Emit after the match
</span>148 <span style=''>    else
</span>149 <span style=''>      </span><span style='background: #AEF1AE'>(
</span>150 <span style=''></span><span style='background: #AEF1AE'>        sti,
</span>151 <span style=''></span><span style='background: #AEF1AE'>        acc, // block completes partial match, so do not emit carry
</span>152 <span style=''></span><span style='background: #AEF1AE'>        Stream.chunk(c.drop(i)),
</span>153 <span style=''></span><span style='background: #AEF1AE'>      )</span><span style=''> // Emit everything after the match
</span>154 <span style=''>
</span>155 <span style=''>  /** Split a chunk in the case of a partial match:
</span>156 <span style=''>    *
</span>157 <span style=''>    * DO NOT USE. Was made private[http4s] because
</span>158 <span style=''>    * Jose messed up hard like 5 patches ago and now it breaks bincompat to
</span>159 <span style=''>    * remove.
</span>160 <span style=''>    */
</span>161 <span style=''>  private def splitPartialMatch[F[_]](
</span>162 <span style=''>      middleChunked: Boolean,
</span>163 <span style=''>      currState: Int,
</span>164 <span style=''>      i: Int,
</span>165 <span style=''>      acc: Stream[F, Byte],
</span>166 <span style=''>      carry: Stream[F, Byte],
</span>167 <span style=''>      c: Chunk[Byte],
</span>168 <span style=''>  ): (Int, Stream[F, Byte], Stream[F, Byte]) = {
</span>169 <span style=''>    val ixx = </span><span style='background: #AEF1AE'>i - currState</span><span style=''>
</span>170 <span style=''>    if (middleChunked) </span><span style='background: #AEF1AE'>{
</span>171 <span style=''></span><span style='background: #AEF1AE'>      val (lchunk, rchunk) = c.splitAt(ixx)
</span>172 <span style=''></span><span style='background: #AEF1AE'>      (currState, acc ++ carry ++ Stream.chunk(lchunk), Stream.chunk(rchunk))
</span>173 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''> else
</span>174 <span style=''>      </span><span style='background: #AEF1AE'>(currState, acc, carry ++ Stream.chunk(c))</span><span style=''>
</span>175 <span style=''>  }
</span>176 <span style=''>
</span>177 <span style=''>  /** Split a chunk as part of either a left or right
</span>178 <span style=''>    * stream depending on the byte sequence in `values`.
</span>179 <span style=''>    *
</span>180 <span style=''>    * `state` represents the current counter position
</span>181 <span style=''>    * for `values`, which is necessary to keep track of in the
</span>182 <span style=''>    * case of partial matches.
</span>183 <span style=''>    *
</span>184 <span style=''>    * `acc` holds the cumulative left stream values,
</span>185 <span style=''>    * and `carry` holds the values that may possibly
</span>186 <span style=''>    * be the byte sequence. As such, carry is re-emitted if it was an
</span>187 <span style=''>    * incomplete match, or ignored (as such excluding the sequence
</span>188 <span style=''>    * from the subsequent split stream).
</span>189 <span style=''>    */
</span>190 <span style=''>  private[http4s] def splitOnChunk[F[_]](
</span>191 <span style=''>      values: Array[Byte],
</span>192 <span style=''>      state: Int,
</span>193 <span style=''>      c: Chunk[Byte],
</span>194 <span style=''>      acc: Stream[F, Byte],
</span>195 <span style=''>      carry: Stream[F, Byte],
</span>196 <span style=''>  ): (Int, Stream[F, Byte], Stream[F, Byte]) = {
</span>197 <span style=''>    var i = </span><span style='background: #AEF1AE'>0</span><span style=''>
</span>198 <span style=''>    var currState = state
</span>199 <span style=''>    val len = </span><span style='background: #AEF1AE'>values.length</span><span style=''>
</span>200 <span style=''>    while (</span><span style='background: #AEF1AE'>currState &lt; len &amp;&amp; i &lt; c.size</span><span style=''>) </span><span style='background: #AEF1AE'>{
</span>201 <span style=''></span><span style='background: #AEF1AE'>      if (c(i) == values(currState))
</span>202 <span style=''></span><span style='background: #AEF1AE'>        currState += 1
</span>203 <span style=''></span><span style='background: #AEF1AE'>      else if (c(i) == values(0))
</span>204 <span style=''></span><span style='background: #AEF1AE'>        currState = 1
</span>205 <span style=''></span><span style='background: #AEF1AE'>      else
</span>206 <span style=''></span><span style='background: #AEF1AE'>        currState = 0
</span>207 <span style=''></span><span style='background: #AEF1AE'>      i += 1
</span>208 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>209 <span style=''>    // It will only be zero if
</span>210 <span style=''>    // the chunk matches from the very beginning,
</span>211 <span style=''>    // since currstate can never be greater than
</span>212 <span style=''>    // (i + state).
</span>213 <span style=''>    val middleChunked = </span><span style='background: #AEF1AE'>i + state - currState &gt; 0</span><span style=''>
</span>214 <span style=''>
</span>215 <span style=''>    if (</span><span style='background: #AEF1AE'>currState == 0</span><span style=''>)
</span>216 <span style=''>      </span><span style='background: #AEF1AE'>(0, acc ++ carry ++ Stream.chunk(c), Stream.empty)</span><span style=''>
</span>217 <span style=''>    else </span><span style='background: #AEF1AE'>if (currState == len)
</span>218 <span style=''></span><span style='background: #AEF1AE'>      splitCompleteMatch(middleChunked, currState, i, acc, carry, c)
</span>219 <span style=''></span><span style='background: #AEF1AE'>    else
</span>220 <span style=''></span><span style='background: #AEF1AE'>      splitPartialMatch(middleChunked, currState, i, acc, carry, c)</span><span style=''>
</span>221 <span style=''>  }
</span>222 <span style=''>
</span>223 <span style=''>  /** Split a stream in half based on `values`,
</span>224 <span style=''>    * but check if it is either double dash terminated (end of multipart).
</span>225 <span style=''>    * SplitOrFinish also tracks a header limit size
</span>226 <span style=''>    *
</span>227 <span style=''>    * If it is, drain the epilogue and return the empty stream. if it is not,
</span>228 <span style=''>    * split on the `values` and raise an error if we lack a match
</span>229 <span style=''>    */
</span>230 <span style=''>  private def splitOrFinish[F[_]: Concurrent](
</span>231 <span style=''>      values: Array[Byte],
</span>232 <span style=''>      stream: Stream[F, Byte],
</span>233 <span style=''>      limit: Int,
</span>234 <span style=''>  ): SplitStream[F] = {
</span>235 <span style=''>    // Check if a particular chunk a final chunk, that is,
</span>236 <span style=''>    // whether it's the boundary plus an extra &quot;--&quot;, indicating it's
</span>237 <span style=''>    // the last boundary
</span>238 <span style=''>    def checkIfLast(c: Chunk[Byte], rest: Stream[F, Byte]): SplitStream[F] = {
</span>239 <span style=''>      // precond: both c1 and c2 are nonempty chunks
</span>240 <span style=''>      def checkTwoNonEmpty(
</span>241 <span style=''>          c1: Chunk[Byte],
</span>242 <span style=''>          c2: Chunk[Byte],
</span>243 <span style=''>          remaining: Stream[F, Byte],
</span>244 <span style=''>      ): SplitStream[F] =
</span>245 <span style=''>        if (</span><span style='background: #AEF1AE'>c1(0) == dashByte &amp;&amp; c2(0) == dashByte</span><span style=''>)
</span>246 <span style=''>          // Drain the multipart epilogue.
</span>247 <span style=''>          </span><span style='background: #AEF1AE'>Pull.eval(rest.compile.drain) *&gt;
</span>248 <span style=''></span><span style='background: #AEF1AE'>            Pull.pure((streamEmpty, streamEmpty))</span><span style=''>
</span>249 <span style=''>        else </span><span style='background: #AEF1AE'>{
</span>250 <span style=''></span><span style='background: #AEF1AE'>          val (ix, l, r, add) =
</span>251 <span style=''></span><span style='background: #AEF1AE'>            splitOnChunkLimited[F](
</span>252 <span style=''></span><span style='background: #AEF1AE'>              values,
</span>253 <span style=''></span><span style='background: #AEF1AE'>              0,
</span>254 <span style=''></span><span style='background: #AEF1AE'>              Chunk.array(c1.toArray[Byte] ++ c2.toArray[Byte]),
</span>255 <span style=''></span><span style='background: #AEF1AE'>              Stream.empty,
</span>256 <span style=''></span><span style='background: #AEF1AE'>              Stream.empty,
</span>257 <span style=''></span><span style='background: #AEF1AE'>            )
</span>258 <span style=''></span><span style='background: #AEF1AE'>          go(remaining, ix, l, r, add)
</span>259 <span style=''></span><span style='background: #AEF1AE'>        }</span><span style=''>
</span>260 <span style=''>
</span>261 <span style=''>      if (</span><span style='background: #AEF1AE'>c.size == 1</span><span style=''>)
</span>262 <span style=''>        </span><span style='background: #AEF1AE'>rest.pull.uncons.flatMap {
</span>263 <span style=''></span><span style='background: #AEF1AE'>          case Some((chnk, remaining)) =&gt;
</span>264 <span style=''></span><span style='background: #AEF1AE'>            checkTwoNonEmpty(c, chnk, remaining)
</span>265 <span style=''></span><span style='background: #AEF1AE'>          case None =&gt;
</span>266 <span style=''></span><span style='background: #AEF1AE'>            </span><span style='background: #F0ADAD'>Pull.raiseError[F](MalformedMessageBodyFailure(&quot;Malformed Multipart ending&quot;))</span><span style='background: #AEF1AE'>
</span>267 <span style=''></span><span style='background: #AEF1AE'>        }</span><span style=''>
</span>268 <span style=''>      else </span><span style='background: #AEF1AE'>if (c(0) == dashByte &amp;&amp; c(1) == dashByte)
</span>269 <span style=''></span><span style='background: #AEF1AE'>        // Drain the multipart epilogue.
</span>270 <span style=''></span><span style='background: #AEF1AE'>        Pull.eval(rest.compile.drain) *&gt;
</span>271 <span style=''></span><span style='background: #AEF1AE'>          Pull.pure((streamEmpty, streamEmpty))
</span>272 <span style=''></span><span style='background: #AEF1AE'>      else {
</span>273 <span style=''></span><span style='background: #AEF1AE'>        val (ix, l, r, add) =
</span>274 <span style=''></span><span style='background: #AEF1AE'>          splitOnChunkLimited[F](values, 0, c, Stream.empty, Stream.empty)
</span>275 <span style=''></span><span style='background: #AEF1AE'>        go(rest, ix, l, r, add)
</span>276 <span style=''></span><span style='background: #AEF1AE'>      }</span><span style=''>
</span>277 <span style=''>    }
</span>278 <span style=''>
</span>279 <span style=''>    def go(
</span>280 <span style=''>        s: Stream[F, Byte],
</span>281 <span style=''>        state: Int,
</span>282 <span style=''>        lacc: Stream[F, Byte],
</span>283 <span style=''>        racc: Stream[F, Byte],
</span>284 <span style=''>        limitCTR: Int,
</span>285 <span style=''>    ): SplitStream[F] =
</span>286 <span style=''>      if (</span><span style='background: #AEF1AE'>limitCTR &gt;= limit</span><span style=''>)
</span>287 <span style=''>        </span><span style='background: #AEF1AE'>Pull.raiseError[F](
</span>288 <span style=''></span><span style='background: #AEF1AE'>          MalformedMessageBodyFailure(s&quot;Part header was longer than $limit-byte limit&quot;)
</span>289 <span style=''></span><span style='background: #AEF1AE'>        )</span><span style=''>
</span>290 <span style=''>      else </span><span style='background: #AEF1AE'>if (state == values.length)
</span>291 <span style=''></span><span style='background: #AEF1AE'>        Pull.pure((lacc, racc ++ s))
</span>292 <span style=''></span><span style='background: #AEF1AE'>      else
</span>293 <span style=''></span><span style='background: #AEF1AE'>        s.pull.uncons.flatMap {
</span>294 <span style=''></span><span style='background: #AEF1AE'>          case Some((chnk, str)) =&gt;
</span>295 <span style=''></span><span style='background: #AEF1AE'>            val (ix, l, r, add) = splitOnChunkLimited[F](values, state, chnk, lacc, racc)
</span>296 <span style=''></span><span style='background: #AEF1AE'>            go(str, ix, l, r, limitCTR + add)
</span>297 <span style=''></span><span style='background: #AEF1AE'>          case None =&gt;
</span>298 <span style=''></span><span style='background: #AEF1AE'>            </span><span style='background: #F0ADAD'>Pull.raiseError[F](MalformedMessageBodyFailure(&quot;Invalid boundary - partial boundary&quot;))</span><span style='background: #AEF1AE'>
</span>299 <span style=''></span><span style='background: #AEF1AE'>        }</span><span style=''>
</span>300 <span style=''>
</span>301 <span style=''>    </span><span style='background: #AEF1AE'>stream.pull.uncons.flatMap {
</span>302 <span style=''></span><span style='background: #AEF1AE'>      case Some((chunk, rest)) =&gt;
</span>303 <span style=''></span><span style='background: #AEF1AE'>        checkIfLast(chunk, rest)
</span>304 <span style=''></span><span style='background: #AEF1AE'>      case None =&gt;
</span>305 <span style=''></span><span style='background: #AEF1AE'>        </span><span style='background: #F0ADAD'>Pull.raiseError[F](MalformedMessageBodyFailure(&quot;Invalid boundary - partial boundary&quot;))</span><span style='background: #AEF1AE'>
</span>306 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>307 <span style=''>  }
</span>308 <span style=''>
</span>309 <span style=''>  /** Take the stream of headers separated by
</span>310 <span style=''>    * double CRLF bytes and return the headers
</span>311 <span style=''>    */
</span>312 <span style=''>  private def parseHeaders[F[_]: Concurrent](strim: Stream[F, Byte]): F[Headers] = {
</span>313 <span style=''>    def tailrecParse(s: Stream[F, Byte], headers: Headers): Pull[F, Headers, Unit] =
</span>314 <span style=''>      </span><span style='background: #AEF1AE'>splitHalf[F](CRLFBytesN, s).flatMap { case (l, r) =&gt;
</span>315 <span style=''></span><span style='background: #AEF1AE'>        l.through(fs2.text.utf8.decode[F])
</span>316 <span style=''></span><span style='background: #AEF1AE'>          .fold(&quot;&quot;)(_ ++ _)
</span>317 <span style=''></span><span style='background: #AEF1AE'>          .map { string =&gt;
</span>318 <span style=''></span><span style='background: #AEF1AE'>            val ix = string.indexOf(':')
</span>319 <span style=''></span><span style='background: #AEF1AE'>            if (ix &gt;= 0)
</span>320 <span style=''></span><span style='background: #AEF1AE'>              headers.put(
</span>321 <span style=''></span><span style='background: #AEF1AE'>                Header.Raw(CIString(string.substring(0, ix)), string.substring(ix + 1).trim)
</span>322 <span style=''></span><span style='background: #AEF1AE'>              )
</span>323 <span style=''></span><span style='background: #AEF1AE'>            else
</span>324 <span style=''></span><span style='background: #AEF1AE'>              headers
</span>325 <span style=''></span><span style='background: #AEF1AE'>          }
</span>326 <span style=''></span><span style='background: #AEF1AE'>          .pull
</span>327 <span style=''></span><span style='background: #AEF1AE'>          .echo &gt;&gt; r.pull.uncons.flatMap {
</span>328 <span style=''></span><span style='background: #AEF1AE'>          case Some(_) =&gt;
</span>329 <span style=''></span><span style='background: #AEF1AE'>            tailrecParse(r, headers)
</span>330 <span style=''></span><span style='background: #AEF1AE'>          case None =&gt;
</span>331 <span style=''></span><span style='background: #AEF1AE'>            Pull.done
</span>332 <span style=''></span><span style='background: #AEF1AE'>        }
</span>333 <span style=''></span><span style='background: #AEF1AE'>      }</span><span style=''>
</span>334 <span style=''>
</span>335 <span style=''>    </span><span style='background: #AEF1AE'>tailrecParse(strim, Headers.empty).stream.compile.foldMonoid</span><span style=''>
</span>336 <span style=''>  }
</span>337 <span style=''>
</span>338 <span style=''>  /** Spit our `Stream[F, Byte]` into two halves.
</span>339 <span style=''>    * If we reach the end and the state is 0 (meaning we didn't match at all),
</span>340 <span style=''>    * then we return the concatenated parts of the stream.
</span>341 <span style=''>    *
</span>342 <span style=''>    * This method _always_ caps
</span>343 <span style=''>    */
</span>344 <span style=''>  private def splitHalf[F[_]](values: Array[Byte], stream: Stream[F, Byte]): SplitStream[F] = {
</span>345 <span style=''>    def go(
</span>346 <span style=''>        s: Stream[F, Byte],
</span>347 <span style=''>        state: Int,
</span>348 <span style=''>        lacc: Stream[F, Byte],
</span>349 <span style=''>        racc: Stream[F, Byte],
</span>350 <span style=''>    ): SplitStream[F] =
</span>351 <span style=''>      if (</span><span style='background: #AEF1AE'>state == values.length</span><span style=''>)
</span>352 <span style=''>        </span><span style='background: #AEF1AE'>Pull.pure((lacc, racc ++ s))</span><span style=''>
</span>353 <span style=''>      else
</span>354 <span style=''>        </span><span style='background: #AEF1AE'>s.pull.uncons.flatMap {
</span>355 <span style=''></span><span style='background: #AEF1AE'>          case Some((chnk, str)) =&gt;
</span>356 <span style=''></span><span style='background: #AEF1AE'>            val (ix, l, r) = splitOnChunk[F](values, state, chnk, lacc, racc)
</span>357 <span style=''></span><span style='background: #AEF1AE'>            go(str, ix, l, r)
</span>358 <span style=''></span><span style='background: #AEF1AE'>          case None =&gt;
</span>359 <span style=''></span><span style='background: #AEF1AE'>            // We got to the end, and matched on nothing.
</span>360 <span style=''></span><span style='background: #AEF1AE'>            Pull.pure((lacc ++ racc, streamEmpty))
</span>361 <span style=''></span><span style='background: #AEF1AE'>        }</span><span style=''>
</span>362 <span style=''>
</span>363 <span style=''>    </span><span style='background: #AEF1AE'>stream.pull.uncons.flatMap {
</span>364 <span style=''></span><span style='background: #AEF1AE'>      case Some((chunk, rest)) =&gt;
</span>365 <span style=''></span><span style='background: #AEF1AE'>        val (ix, l, r) = splitOnChunk[F](values, 0, chunk, Stream.empty, Stream.empty)
</span>366 <span style=''></span><span style='background: #AEF1AE'>        go(rest, ix, l, r)
</span>367 <span style=''></span><span style='background: #AEF1AE'>      case None =&gt;
</span>368 <span style=''></span><span style='background: #AEF1AE'>        </span><span style='background: #F0ADAD'>Pull.pure((streamEmpty, streamEmpty))</span><span style='background: #AEF1AE'>
</span>369 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>370 <span style=''>  }
</span>371 <span style=''>
</span>372 <span style=''>  /** Split a chunk in the case of a complete match:
</span>373 <span style=''>    *
</span>374 <span style=''>    * If it is a chunk that is between a partial match
</span>375 <span style=''>    * (middleChunked), consider the prior partial match
</span>376 <span style=''>    * as part of the data to emit.
</span>377 <span style=''>    *
</span>378 <span style=''>    * If it is a fully matched, fresh chunk (no carry over partial match),
</span>379 <span style=''>    * emit everything until the match, and everything after the match.
</span>380 <span style=''>    *
</span>381 <span style=''>    * If it is the continuation of a partial match,
</span>382 <span style=''>    * emit everything after the partial match.
</span>383 <span style=''>    */
</span>384 <span style=''>  private def splitCompleteLimited[F[_]](
</span>385 <span style=''>      state: Int,
</span>386 <span style=''>      middleChunked: Boolean,
</span>387 <span style=''>      sti: Int,
</span>388 <span style=''>      i: Int,
</span>389 <span style=''>      acc: Stream[F, Byte],
</span>390 <span style=''>      carry: Stream[F, Byte],
</span>391 <span style=''>      c: Chunk[Byte],
</span>392 <span style=''>  ): (Int, Stream[F, Byte], Stream[F, Byte], Int) =
</span>393 <span style=''>    if (middleChunked)
</span>394 <span style=''>      </span><span style='background: #AEF1AE'>(
</span>395 <span style=''></span><span style='background: #AEF1AE'>        sti,
</span>396 <span style=''></span><span style='background: #AEF1AE'>        // Emit the partial match as well
</span>397 <span style=''></span><span style='background: #AEF1AE'>        acc ++ carry ++ Stream.chunk(c.take(i - sti)),
</span>398 <span style=''></span><span style='background: #AEF1AE'>        // Emit after the match
</span>399 <span style=''></span><span style='background: #AEF1AE'>        Stream.chunk(c.drop(i)),
</span>400 <span style=''></span><span style='background: #AEF1AE'>        state + i - sti,
</span>401 <span style=''></span><span style='background: #AEF1AE'>      )</span><span style=''>
</span>402 <span style=''>    else
</span>403 <span style=''>      </span><span style='background: #AEF1AE'>(
</span>404 <span style=''></span><span style='background: #AEF1AE'>        sti,
</span>405 <span style=''></span><span style='background: #AEF1AE'>        acc, // block completes partial match, so do not emit carry
</span>406 <span style=''></span><span style='background: #AEF1AE'>        Stream.chunk(c.drop(i)), // Emit everything after the match
</span>407 <span style=''></span><span style='background: #AEF1AE'>        0,
</span>408 <span style=''></span><span style='background: #AEF1AE'>      )</span><span style=''>
</span>409 <span style=''>
</span>410 <span style=''>  /** Split a chunk in the case of a partial match:
</span>411 <span style=''>    *
</span>412 <span style=''>    * If it is a chunk that is between a partial match
</span>413 <span style=''>    * (middle chunked), the prior partial match is added to
</span>414 <span style=''>    * the accumulator, and the current partial match is
</span>415 <span style=''>    * considered to carry over.
</span>416 <span style=''>    *
</span>417 <span style=''>    * If it is a fresh chunk (no carry over partial match),
</span>418 <span style=''>    * everything prior to the partial match is added to the accumulator,
</span>419 <span style=''>    * and the partial match is considered the carry over.
</span>420 <span style=''>    *
</span>421 <span style=''>    * Else, if the whole block is a partial match,
</span>422 <span style=''>    * add it to the carry over
</span>423 <span style=''>    */
</span>424 <span style=''>  private[http4s] def splitPartialLimited[F[_]](
</span>425 <span style=''>      state: Int,
</span>426 <span style=''>      middleChunked: Boolean,
</span>427 <span style=''>      currState: Int,
</span>428 <span style=''>      i: Int,
</span>429 <span style=''>      acc: Stream[F, Byte],
</span>430 <span style=''>      carry: Stream[F, Byte],
</span>431 <span style=''>      c: Chunk[Byte],
</span>432 <span style=''>  ): (Int, Stream[F, Byte], Stream[F, Byte], Int) = {
</span>433 <span style=''>    val ixx = </span><span style='background: #AEF1AE'>i - currState</span><span style=''>
</span>434 <span style=''>    if (middleChunked) </span><span style='background: #AEF1AE'>{
</span>435 <span style=''></span><span style='background: #AEF1AE'>      val (lchunk, rchunk) = c.splitAt(ixx)
</span>436 <span style=''></span><span style='background: #AEF1AE'>      (
</span>437 <span style=''></span><span style='background: #AEF1AE'>        currState,
</span>438 <span style=''></span><span style='background: #AEF1AE'>        acc ++ carry ++ Stream.chunk(lchunk), // Emit previous carry
</span>439 <span style=''></span><span style='background: #AEF1AE'>        Stream.chunk(rchunk),
</span>440 <span style=''></span><span style='background: #AEF1AE'>        state + ixx,
</span>441 <span style=''></span><span style='background: #AEF1AE'>      )
</span>442 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''> else
</span>443 <span style=''>      // Whole thing is partial match
</span>444 <span style=''>      </span><span style='background: #AEF1AE'>(currState, acc, carry ++ Stream.chunk(c), 0)</span><span style=''>
</span>445 <span style=''>  }
</span>446 <span style=''>
</span>447 <span style=''>  private[http4s] def splitOnChunkLimited[F[_]](
</span>448 <span style=''>      values: Array[Byte],
</span>449 <span style=''>      state: Int,
</span>450 <span style=''>      c: Chunk[Byte],
</span>451 <span style=''>      acc: Stream[F, Byte],
</span>452 <span style=''>      carry: Stream[F, Byte],
</span>453 <span style=''>  ): (Int, Stream[F, Byte], Stream[F, Byte], Int) = {
</span>454 <span style=''>    var i = </span><span style='background: #AEF1AE'>0</span><span style=''>
</span>455 <span style=''>    var currState = state
</span>456 <span style=''>    val len = </span><span style='background: #AEF1AE'>values.length</span><span style=''>
</span>457 <span style=''>    while (</span><span style='background: #AEF1AE'>currState &lt; len &amp;&amp; i &lt; c.size</span><span style=''>) </span><span style='background: #AEF1AE'>{
</span>458 <span style=''></span><span style='background: #AEF1AE'>      if (c(i) == values(currState))
</span>459 <span style=''></span><span style='background: #AEF1AE'>        currState += 1
</span>460 <span style=''></span><span style='background: #AEF1AE'>      else if (c(i) == values(0))
</span>461 <span style=''></span><span style='background: #AEF1AE'>        </span><span style='background: #F0ADAD'>currState = 1</span><span style='background: #AEF1AE'>
</span>462 <span style=''></span><span style='background: #AEF1AE'>      else
</span>463 <span style=''></span><span style='background: #AEF1AE'>        currState = 0
</span>464 <span style=''></span><span style='background: #AEF1AE'>      i += 1
</span>465 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>466 <span style=''>
</span>467 <span style=''>    // It will only be zero if
</span>468 <span style=''>    // the chunk matches from the very beginning,
</span>469 <span style=''>    // since currstate can never be greater than
</span>470 <span style=''>    // (i + state).
</span>471 <span style=''>    val middleChunked = </span><span style='background: #AEF1AE'>i + state - currState &gt; 0</span><span style=''>
</span>472 <span style=''>
</span>473 <span style=''>    if (</span><span style='background: #AEF1AE'>currState == 0</span><span style=''>)
</span>474 <span style=''>      </span><span style='background: #AEF1AE'>(0, acc ++ carry ++ Stream.chunk(c), Stream.empty, i)</span><span style=''>
</span>475 <span style=''>    else </span><span style='background: #AEF1AE'>if (currState == len)
</span>476 <span style=''></span><span style='background: #AEF1AE'>      splitCompleteLimited(state, middleChunked, currState, i, acc, carry, c)
</span>477 <span style=''></span><span style='background: #AEF1AE'>    else
</span>478 <span style=''></span><span style='background: #AEF1AE'>      splitPartialLimited(state, middleChunked, currState, i, acc, carry, c)</span><span style=''>
</span>479 <span style=''>  }
</span>480 <span style=''>
</span>481 <span style=''>  // //////////////////////////////////////////////////////////
</span>482 <span style=''>  // File writing encoder
</span>483 <span style=''>  // /////////////////////////////////////////////////////////
</span>484 <span style=''>
</span>485 <span style=''>  /** Same as the other streamed parsing, except
</span>486 <span style=''>    * after a particular size, it buffers on a File.
</span>487 <span style=''>    */
</span>488 <span style=''>  @deprecated(&quot;Use parseSupervisedFile&quot;, &quot;0.23&quot;)
</span>489 <span style=''>  def parseStreamedFile[F[_]: Concurrent: Files](
</span>490 <span style=''>      boundary: Boundary,
</span>491 <span style=''>      limit: Int = 1024,
</span>492 <span style=''>      maxSizeBeforeWrite: Int = 52428800,
</span>493 <span style=''>      maxParts: Int = 20,
</span>494 <span style=''>      failOnLimit: Boolean = false,
</span>495 <span style=''>  ): Pipe[F, Byte, Multipart[F]] = { st =&gt;
</span>496 <span style=''>    </span><span style='background: #AEF1AE'>st.through(
</span>497 <span style=''></span><span style='background: #AEF1AE'>      parseToPartsStreamedFile(boundary, limit, maxSizeBeforeWrite, maxParts, failOnLimit)
</span>498 <span style=''></span><span style='background: #AEF1AE'>    ).fold(Vector.empty[Part[F]])(_ :+ _)
</span>499 <span style=''></span><span style='background: #AEF1AE'>      .map(Multipart(_, boundary))</span><span style=''>
</span>500 <span style=''>  }
</span>501 <span style=''>
</span>502 <span style=''>  @deprecated(&quot;Use parseSupervisedFile&quot;, &quot;0.23&quot;)
</span>503 <span style=''>  def parseToPartsStreamedFile[F[_]: Concurrent: Files](
</span>504 <span style=''>      boundary: Boundary,
</span>505 <span style=''>      limit: Int = 1024,
</span>506 <span style=''>      maxSizeBeforeWrite: Int = 52428800,
</span>507 <span style=''>      maxParts: Int = 20,
</span>508 <span style=''>      failOnLimit: Boolean = false,
</span>509 <span style=''>  ): Pipe[F, Byte, Part[F]] = {
</span>510 <span style=''>
</span>511 <span style=''>    val pullParts: Stream[F, Event] =&gt; Stream[F, Part[F]] =
</span>512 <span style=''>      </span><span style='background: #AEF1AE'>Pull
</span>513 <span style=''></span><span style='background: #AEF1AE'>        .loop[F, Part[F], Stream[F, Event]](
</span>514 <span style=''></span><span style='background: #AEF1AE'>          _.pull.uncons1.flatMap(
</span>515 <span style=''></span><span style='background: #AEF1AE'>            _.traverse {
</span>516 <span style=''></span><span style='background: #AEF1AE'>              case (PartStart(headers), s) =&gt;
</span>517 <span style=''></span><span style='background: #AEF1AE'>                partBodyFileStream(s, maxSizeBeforeWrite)
</span>518 <span style=''></span><span style='background: #AEF1AE'>                  .flatMap { case (body, rest) =&gt;
</span>519 <span style=''></span><span style='background: #AEF1AE'>                    Pull.output1(Part(headers, body)).as(rest)
</span>520 <span style=''></span><span style='background: #AEF1AE'>                  }
</span>521 <span style=''></span><span style='background: #AEF1AE'>              // Shouldn't happen if the `parseToEventsStream` contract holds.
</span>522 <span style=''></span><span style='background: #AEF1AE'>              case (_: PartChunk | PartEnd, _) =&gt;
</span>523 <span style=''></span><span style='background: #AEF1AE'>                Pull.raiseError(bug(&quot;Missing PartStart&quot;))
</span>524 <span style=''></span><span style='background: #AEF1AE'>            }
</span>525 <span style=''></span><span style='background: #AEF1AE'>          )
</span>526 <span style=''></span><span style='background: #AEF1AE'>        )(_)
</span>527 <span style=''></span><span style='background: #AEF1AE'>        .stream</span><span style=''>
</span>528 <span style=''>
</span>529 <span style=''>    </span><span style='background: #AEF1AE'>_.through(
</span>530 <span style=''></span><span style='background: #AEF1AE'>      parseEvents[F](boundary, limit)
</span>531 <span style=''></span><span style='background: #AEF1AE'>    ).through(
</span>532 <span style=''></span><span style='background: #AEF1AE'>      limitParts[F](maxParts, failOnLimit)
</span>533 <span style=''></span><span style='background: #AEF1AE'>    ).through(pullParts)</span><span style=''>
</span>534 <span style=''>  }
</span>535 <span style=''>
</span>536 <span style=''>  private[this] def limitParts[F[_]: RaiseThrowable](
</span>537 <span style=''>      maxParts: Int,
</span>538 <span style=''>      failOnLimit: Boolean,
</span>539 <span style=''>  ): Pipe[F, Event, Event] = {
</span>540 <span style=''>    def go(st: Stream[F, Event], partsCounter: Int): Pull[F, Event, Unit] =
</span>541 <span style=''>      </span><span style='background: #AEF1AE'>st.pull.uncons1.flatMap {
</span>542 <span style=''></span><span style='background: #AEF1AE'>        case Some((event: PartStart, rest)) =&gt;
</span>543 <span style=''></span><span style='background: #AEF1AE'>          if (partsCounter &lt; maxParts) {
</span>544 <span style=''></span><span style='background: #AEF1AE'>            Pull.output1(event) &gt;&gt; go(rest, partsCounter + 1)
</span>545 <span style=''></span><span style='background: #AEF1AE'>          } else if (failOnLimit) {
</span>546 <span style=''></span><span style='background: #AEF1AE'>            Pull.raiseError[F](MalformedMessageBodyFailure(&quot;Parts limit exceeded&quot;))
</span>547 <span style=''></span><span style='background: #AEF1AE'>          } else Pull.done
</span>548 <span style=''></span><span style='background: #AEF1AE'>        case Some((event, rest)) =&gt;
</span>549 <span style=''></span><span style='background: #AEF1AE'>          Pull.output1(event) &gt;&gt; go(rest, partsCounter)
</span>550 <span style=''></span><span style='background: #AEF1AE'>        case None =&gt; Pull.done
</span>551 <span style=''></span><span style='background: #AEF1AE'>      }</span><span style=''>
</span>552 <span style=''>
</span>553 <span style=''>    </span><span style='background: #AEF1AE'>go(_, 0).stream</span><span style=''>
</span>554 <span style=''>  }
</span>555 <span style=''>
</span>556 <span style=''>  // Consume `PartChunk`s until the first `PartEnd`, produce a stream with all the consumed data.
</span>557 <span style=''>  private[this] def partBodyFileStream[F[_]: Concurrent: Files](
</span>558 <span style=''>      stream: Stream[F, Event],
</span>559 <span style=''>      maxBeforeWrite: Int,
</span>560 <span style=''>  ): Pull[F, Nothing, (Stream[F, Byte], Stream[F, Event])] = {
</span>561 <span style=''>    // Consume `PartChunk`s until the first `PartEnd`, and write all the data into the file.
</span>562 <span style=''>    def streamAndWrite(
</span>563 <span style=''>        s: Stream[F, Event],
</span>564 <span style=''>        lacc: Stream[Pure, Byte],
</span>565 <span style=''>        limitCTR: Int,
</span>566 <span style=''>        fileRef: Path,
</span>567 <span style=''>    ): Pull[F, Nothing, Stream[F, Event]] =
</span>568 <span style=''>      if (</span><span style='background: #F0ADAD'>limitCTR &gt;= maxBeforeWrite</span><span style=''>)
</span>569 <span style=''>        </span><span style='background: #F0ADAD'>Pull.eval(
</span>570 <span style=''></span><span style='background: #F0ADAD'>          lacc
</span>571 <span style=''></span><span style='background: #F0ADAD'>            .through(Files[F].writeAll(fileRef, Flags.Append))
</span>572 <span style=''></span><span style='background: #F0ADAD'>            .compile
</span>573 <span style=''></span><span style='background: #F0ADAD'>            .drain
</span>574 <span style=''></span><span style='background: #F0ADAD'>        ) &gt;&gt; streamAndWrite(s, Stream.empty, 0, fileRef)</span><span style=''>
</span>575 <span style=''>      else
</span>576 <span style=''>        </span><span style='background: #F0ADAD'>s.pull.uncons1.flatMap {
</span>577 <span style=''></span><span style='background: #F0ADAD'>          case Some((PartChunk(chnk), str)) =&gt;
</span>578 <span style=''></span><span style='background: #F0ADAD'>            streamAndWrite(str, lacc ++ Stream.chunk(chnk), limitCTR + chnk.size, fileRef)
</span>579 <span style=''></span><span style='background: #F0ADAD'>          case Some((PartEnd, str)) =&gt;
</span>580 <span style=''></span><span style='background: #F0ADAD'>            Pull
</span>581 <span style=''></span><span style='background: #F0ADAD'>              .eval(
</span>582 <span style=''></span><span style='background: #F0ADAD'>                lacc
</span>583 <span style=''></span><span style='background: #F0ADAD'>                  .through(Files[F].writeAll(fileRef, Flags.Append))
</span>584 <span style=''></span><span style='background: #F0ADAD'>                  .compile
</span>585 <span style=''></span><span style='background: #F0ADAD'>                  .drain
</span>586 <span style=''></span><span style='background: #F0ADAD'>              )
</span>587 <span style=''></span><span style='background: #F0ADAD'>              .as(str)
</span>588 <span style=''></span><span style='background: #F0ADAD'>          // Shouldn't happen if the `parseToEventsStream` contract holds.
</span>589 <span style=''></span><span style='background: #F0ADAD'>          case Some((_: PartStart, _)) | None =&gt;
</span>590 <span style=''></span><span style='background: #F0ADAD'>            Pull.raiseError(bug(&quot;Missing PartEnd&quot;))
</span>591 <span style=''></span><span style='background: #F0ADAD'>        }</span><span style=''>
</span>592 <span style=''>
</span>593 <span style=''>    // Consume `PartChunks` until the first `PartEnd`, accumulating the data in memory.
</span>594 <span style=''>    // Produce a stream with all the accumulated data.
</span>595 <span style=''>    // Fall back to `streamAndWrite` after the limit is reached
</span>596 <span style=''>    def go(
</span>597 <span style=''>        s: Stream[F, Event],
</span>598 <span style=''>        lacc: Stream[Pure, Byte],
</span>599 <span style=''>        limitCTR: Int,
</span>600 <span style=''>    ): Pull[F, Nothing, (Stream[F, Byte], Stream[F, Event])] =
</span>601 <span style=''>      if (</span><span style='background: #AEF1AE'>limitCTR &gt;= maxBeforeWrite</span><span style=''>)
</span>602 <span style=''>        </span><span style='background: #F0ADAD'>Pull
</span>603 <span style=''></span><span style='background: #F0ADAD'>          .eval(Files[F].tempFile(None, &quot;&quot;, &quot;&quot;, None).allocated)
</span>604 <span style=''></span><span style='background: #F0ADAD'>          .flatMap { case (path, cleanup) =&gt;
</span>605 <span style=''></span><span style='background: #F0ADAD'>            streamAndWrite(s, lacc, limitCTR, path)
</span>606 <span style=''></span><span style='background: #F0ADAD'>              .tupleLeft(Files[F].readAll(path, maxBeforeWrite, Flags.Read).onFinalizeWeak(cleanup))
</span>607 <span style=''></span><span style='background: #F0ADAD'>              .onError { case _ =&gt; Pull.eval(cleanup) }
</span>608 <span style=''></span><span style='background: #F0ADAD'>          }</span><span style=''>
</span>609 <span style=''>      else
</span>610 <span style=''>        </span><span style='background: #AEF1AE'>s.pull.uncons1.flatMap {
</span>611 <span style=''></span><span style='background: #AEF1AE'>          case Some((PartChunk(chnk), str)) =&gt;
</span>612 <span style=''></span><span style='background: #AEF1AE'>            go(str, lacc ++ Stream.chunk(chnk), limitCTR + chnk.size)
</span>613 <span style=''></span><span style='background: #AEF1AE'>          case Some((PartEnd, str)) =&gt;
</span>614 <span style=''></span><span style='background: #AEF1AE'>            Pull.pure((lacc, str))
</span>615 <span style=''></span><span style='background: #AEF1AE'>          // Shouldn't happen if the `parseToEventsStream` contract holds.
</span>616 <span style=''></span><span style='background: #AEF1AE'>          case Some((_: PartStart, _)) | None =&gt;
</span>617 <span style=''></span><span style='background: #AEF1AE'>            </span><span style='background: #F0ADAD'>Pull.raiseError(bug(&quot;Missing PartEnd&quot;))</span><span style='background: #AEF1AE'>
</span>618 <span style=''></span><span style='background: #AEF1AE'>        }</span><span style=''>
</span>619 <span style=''>
</span>620 <span style=''>    </span><span style='background: #AEF1AE'>go(stream, Stream.empty, 0)</span><span style=''>
</span>621 <span style=''>  }
</span>622 <span style=''>
</span>623 <span style=''>  // ///////////////////////////////////
</span>624 <span style=''>  // Resource-safe file-based parser //
</span>625 <span style=''>  // ///////////////////////////////////
</span>626 <span style=''>
</span>627 <span style=''>  /** Like parseStreamedFile, but the produced parts' resources are managed by the supervisor.
</span>628 <span style=''>    */
</span>629 <span style=''>  private[multipart] def parseSupervisedFile[F[_]: Concurrent: Files](
</span>630 <span style=''>      supervisor: Supervisor[F],
</span>631 <span style=''>      boundary: Boundary,
</span>632 <span style=''>      limit: Int = 1024,
</span>633 <span style=''>      maxSizeBeforeWrite: Int = 52428800,
</span>634 <span style=''>      maxParts: Int = 20,
</span>635 <span style=''>      failOnLimit: Boolean = false,
</span>636 <span style=''>      chunkSize: Int = 8192,
</span>637 <span style=''>  ): Pipe[F, Byte, Multipart[F]] = { st =&gt;
</span>638 <span style=''>    </span><span style='background: #AEF1AE'>st.through(
</span>639 <span style=''></span><span style='background: #AEF1AE'>      parseToPartsSupervisedFile(
</span>640 <span style=''></span><span style='background: #AEF1AE'>        supervisor,
</span>641 <span style=''></span><span style='background: #AEF1AE'>        boundary,
</span>642 <span style=''></span><span style='background: #AEF1AE'>        limit,
</span>643 <span style=''></span><span style='background: #AEF1AE'>        maxSizeBeforeWrite,
</span>644 <span style=''></span><span style='background: #AEF1AE'>        maxParts,
</span>645 <span style=''></span><span style='background: #AEF1AE'>        failOnLimit,
</span>646 <span style=''></span><span style='background: #AEF1AE'>        chunkSize,
</span>647 <span style=''></span><span style='background: #AEF1AE'>      )
</span>648 <span style=''></span><span style='background: #AEF1AE'>    ).fold(Vector.empty[Part[F]])(_ :+ _)
</span>649 <span style=''></span><span style='background: #AEF1AE'>      .map(Multipart(_, boundary))</span><span style=''>
</span>650 <span style=''>  }
</span>651 <span style=''>
</span>652 <span style=''>  private[multipart] def parseToPartsSupervisedFile[F[_]](
</span>653 <span style=''>      supervisor: Supervisor[F],
</span>654 <span style=''>      boundary: Boundary,
</span>655 <span style=''>      limit: Int = 1024,
</span>656 <span style=''>      maxSizeBeforeWrite: Int = 52428800,
</span>657 <span style=''>      maxParts: Int = 20,
</span>658 <span style=''>      failOnLimit: Boolean = false,
</span>659 <span style=''>      chunkSize: Int = 8192,
</span>660 <span style=''>  )(implicit F: Concurrent[F], files: Files[F]): Pipe[F, Byte, Part[F]] = {
</span>661 <span style=''>    val createFile = </span><span style='background: #AEF1AE'>superviseResource(supervisor, files.tempFile)</span><span style=''>
</span>662 <span style=''>    def append(file: Path, bytes: Stream[Pure, Byte]): F[Unit] =
</span>663 <span style=''>      </span><span style='background: #AEF1AE'>bytes.through(files.writeAll(file, Flags.Append)).compile.drain</span><span style=''>
</span>664 <span style=''>
</span>665 <span style=''>    final case class Acc(file: Option[Path], bytes: Stream[Pure, Byte], bytesSize: Int)
</span>666 <span style=''>
</span>667 <span style=''>    def stepPartChunk(oldAcc: Acc, chunk: Chunk[Byte]): F[Acc] = {
</span>668 <span style=''>      val newSize = </span><span style='background: #AEF1AE'>oldAcc.bytesSize + chunk.size</span><span style=''>
</span>669 <span style=''>      val newBytes = </span><span style='background: #AEF1AE'>oldAcc.bytes ++ Stream.chunk(chunk)</span><span style=''>
</span>670 <span style=''>      if (</span><span style='background: #AEF1AE'>newSize &gt; maxSizeBeforeWrite</span><span style=''>) {
</span>671 <span style=''>        </span><span style='background: #AEF1AE'>oldAcc.file
</span>672 <span style=''></span><span style='background: #AEF1AE'>          .fold(createFile)(</span><span style='background: #F0ADAD'>F.pure</span><span style='background: #AEF1AE'>)
</span>673 <span style=''></span><span style='background: #AEF1AE'>          .flatTap(append(_, newBytes))
</span>674 <span style=''></span><span style='background: #AEF1AE'>          .map(newFile =&gt; Acc(Some(newFile), Stream.empty, 0))</span><span style=''>
</span>675 <span style=''>      } else </span><span style='background: #AEF1AE'>F.pure(Acc(oldAcc.file, newBytes, newSize))</span><span style=''>
</span>676 <span style=''>    }
</span>677 <span style=''>
</span>678 <span style=''>    val stepPartEnd: Acc =&gt; F[Stream[F, Byte]] = {
</span>679 <span style=''>      case Acc(None, bytes, _) =&gt; </span><span style='background: #AEF1AE'>F.pure(bytes)</span><span style=''>
</span>680 <span style=''>      case Acc(Some(file), bytes, size) =&gt;
</span>681 <span style=''>        </span><span style='background: #AEF1AE'>append(file, bytes)
</span>682 <span style=''></span><span style='background: #AEF1AE'>          .whenA(size &gt; 0)
</span>683 <span style=''></span><span style='background: #AEF1AE'>          .as(
</span>684 <span style=''></span><span style='background: #AEF1AE'>            files.readAll(file, chunkSize = chunkSize, Flags.Read)
</span>685 <span style=''></span><span style='background: #AEF1AE'>          )</span><span style=''>
</span>686 <span style=''>    }
</span>687 <span style=''>
</span>688 <span style=''>    val step: (Option[(Headers, Acc)], Event) =&gt; F[(Option[(Headers, Acc)], Option[Part[F]])] = {
</span>689 <span style=''>      case (None, PartStart(headers)) =&gt;
</span>690 <span style=''>        val newAcc = </span><span style='background: #AEF1AE'>Acc(None, Stream.empty, 0)</span><span style=''>
</span>691 <span style=''>        </span><span style='background: #AEF1AE'>F.pure((Some((headers, newAcc)), None))</span><span style=''>
</span>692 <span style=''>      // Shouldn't happen if the `parseToEventsStream` contract holds.
</span>693 <span style=''>      case (None, _: PartChunk | PartEnd) =&gt;
</span>694 <span style=''>        </span><span style='background: #F0ADAD'>F.raiseError(bug(&quot;Missing PartStart&quot;))</span><span style=''>
</span>695 <span style=''>      case (Some((headers, oldAcc)), PartChunk(chunk)) =&gt;
</span>696 <span style=''>        </span><span style='background: #AEF1AE'>stepPartChunk(oldAcc, chunk).map { newAcc =&gt;
</span>697 <span style=''></span><span style='background: #AEF1AE'>          (Some((headers, newAcc)), None)
</span>698 <span style=''></span><span style='background: #AEF1AE'>        }</span><span style=''>
</span>699 <span style=''>      case (Some((headers, acc)), PartEnd) =&gt;
</span>700 <span style=''>        // Part done - emit it and start over.
</span>701 <span style=''>        </span><span style='background: #AEF1AE'>stepPartEnd(acc)
</span>702 <span style=''></span><span style='background: #AEF1AE'>          .map(body =&gt; (None, Some(Part(headers, body))))</span><span style=''>
</span>703 <span style=''>      // Shouldn't happen if the `parseToEventsStream` contract holds.
</span>704 <span style=''>      case (Some(_), _: PartStart) =&gt;
</span>705 <span style=''>        </span><span style='background: #F0ADAD'>F.raiseError(bug(&quot;Missing PartEnd&quot;))</span><span style=''>
</span>706 <span style=''>    }
</span>707 <span style=''>
</span>708 <span style=''>    </span><span style='background: #AEF1AE'>_.through(
</span>709 <span style=''></span><span style='background: #AEF1AE'>      parseEvents(boundary, limit)
</span>710 <span style=''></span><span style='background: #AEF1AE'>    ).through(
</span>711 <span style=''></span><span style='background: #AEF1AE'>      limitParts(maxParts, failOnLimit)
</span>712 <span style=''></span><span style='background: #AEF1AE'>    ).evalMapAccumulate(none[(Headers, Acc)])(step)
</span>713 <span style=''></span><span style='background: #AEF1AE'>      .mapFilter(_._2)</span><span style=''>
</span>714 <span style=''>  }
</span>715 <span style=''>
</span>716 <span style=''>  // Acquire the resource in a separate fiber, which will remain running until the provided
</span>717 <span style=''>  // supervisor sees fit to cancel it. The resulting action waits for the resource to be acquired.
</span>718 <span style=''>  private[this] def superviseResource[F[_], A](
</span>719 <span style=''>      supervisor: Supervisor[F],
</span>720 <span style=''>      resource: Resource[F, A],
</span>721 <span style=''>  )(implicit F: Concurrent[F]): F[A] =
</span>722 <span style=''>    </span><span style='background: #AEF1AE'>F.deferred[Either[Throwable, A]].flatMap { deferred =&gt;
</span>723 <span style=''></span><span style='background: #AEF1AE'>      supervisor.supervise[Nothing](
</span>724 <span style=''></span><span style='background: #AEF1AE'>        resource.attempt
</span>725 <span style=''></span><span style='background: #AEF1AE'>          .evalTap(deferred.complete)
</span>726 <span style=''></span><span style='background: #AEF1AE'>          // In case of an error the exception brings down the fiber.
</span>727 <span style=''></span><span style='background: #AEF1AE'>          .rethrow
</span>728 <span style=''></span><span style='background: #AEF1AE'>          // Success - keep the resource alive until the supervisor cancels this fiber.
</span>729 <span style=''></span><span style='background: #AEF1AE'>          .useForever
</span>730 <span style=''></span><span style='background: #AEF1AE'>      ) *&gt; deferred.get.rethrow
</span>731 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>732 <span style=''>
</span>733 <span style=''>  // //////////////////////////
</span>734 <span style=''>  // Streaming event parser //
</span>735 <span style=''>  // //////////////////////////
</span>736 <span style=''>
</span>737 <span style=''>  /** Parse a stream of bytes into a stream of part events. The events come in the following order:
</span>738 <span style=''>    *
</span>739 <span style=''>    *   - one `PartStart`;
</span>740 <span style=''>    *   - any number of `PartChunk`s;
</span>741 <span style=''>    *   - one `PartEnd`.
</span>742 <span style=''>    *
</span>743 <span style=''>    * Any number of such sequences may be produced.
</span>744 <span style=''>    */
</span>745 <span style=''>  private[this] def parseEvents[F[_]: Concurrent](
</span>746 <span style=''>      boundary: Boundary,
</span>747 <span style=''>      headerLimit: Int,
</span>748 <span style=''>  ): Pipe[F, Byte, Event] =
</span>749 <span style=''>    </span><span style='background: #AEF1AE'>skipPrelude(boundary, _)
</span>750 <span style=''></span><span style='background: #AEF1AE'>      .flatMap(pullPartsEvents(boundary, _, headerLimit))
</span>751 <span style=''></span><span style='background: #AEF1AE'>      .stream</span><span style=''>
</span>752 <span style=''>
</span>753 <span style=''>  /** Drain the prelude and remove the first boundary. Only traverses until the first
</span>754 <span style=''>    * part.
</span>755 <span style=''>    */
</span>756 <span style=''>  private[this] def skipPrelude[F[_]: Concurrent](
</span>757 <span style=''>      boundary: Boundary,
</span>758 <span style=''>      stream: Stream[F, Byte],
</span>759 <span style=''>  ): Pull[F, Nothing, Stream[F, Byte]] = {
</span>760 <span style=''>    val dashBoundaryBytes = </span><span style='background: #AEF1AE'>StartLineBytesN(boundary)</span><span style=''>
</span>761 <span style=''>
</span>762 <span style=''>    def go(s: Stream[F, Byte], state: Int): Pull[F, Nothing, Stream[F, Byte]] =
</span>763 <span style=''>      </span><span style='background: #AEF1AE'>s.pull.uncons.flatMap {
</span>764 <span style=''></span><span style='background: #AEF1AE'>        case Some((chnk, rest)) =&gt;
</span>765 <span style=''></span><span style='background: #AEF1AE'>          val (ix, remainder) = splitAndIgnorePrev(dashBoundaryBytes, state, chnk)
</span>766 <span style=''></span><span style='background: #AEF1AE'>          if (ix === dashBoundaryBytes.length) Pull.pure(remainder ++ rest)
</span>767 <span style=''></span><span style='background: #AEF1AE'>          else go(rest, ix)
</span>768 <span style=''></span><span style='background: #AEF1AE'>        case None =&gt;
</span>769 <span style=''></span><span style='background: #AEF1AE'>          </span><span style='background: #F0ADAD'>Pull.raiseError[F](MalformedMessageBodyFailure(&quot;Malformed Malformed match&quot;))</span><span style='background: #AEF1AE'>
</span>770 <span style=''></span><span style='background: #AEF1AE'>      }</span><span style=''>
</span>771 <span style=''>
</span>772 <span style=''>    </span><span style='background: #AEF1AE'>go(stream, 0)</span><span style=''>
</span>773 <span style=''>  }
</span>774 <span style=''>
</span>775 <span style=''>  /** Pull part events for parts until the end of the stream. */
</span>776 <span style=''>  private[this] def pullPartsEvents[F[_]: Concurrent](
</span>777 <span style=''>      boundary: Boundary,
</span>778 <span style=''>      stream: Stream[F, Byte],
</span>779 <span style=''>      headerLimit: Int,
</span>780 <span style=''>  ): Pull[F, Event, Unit] = {
</span>781 <span style=''>    val delimiterBytes = </span><span style='background: #AEF1AE'>ExpectedBytesN(boundary)</span><span style=''>
</span>782 <span style=''>
</span>783 <span style=''>    // Headers on the left, the remainder on the right.
</span>784 <span style=''>    type Acc = (Stream[F, Byte], Stream[F, Byte])
</span>785 <span style=''>    val pullPartEvents0: Acc =&gt; Pull[F, Event, Stream[F, Byte]] =
</span>786 <span style=''>      </span><span style='background: #AEF1AE'>(pullPartEvents[F](_, _, delimiterBytes)).tupled</span><span style=''>
</span>787 <span style=''>
</span>788 <span style=''>    </span><span style='background: #AEF1AE'>splitOrFinish[F](DoubleCRLFBytesN, stream, headerLimit)
</span>789 <span style=''></span><span style='background: #AEF1AE'>      // We must have at least one part.
</span>790 <span style=''></span><span style='background: #AEF1AE'>      .ensure(</span><span style='background: #F0ADAD'>MalformedMessageBodyFailure(&quot;Cannot parse empty stream&quot;)</span><span style='background: #AEF1AE'>) {
</span>791 <span style=''></span><span style='background: #AEF1AE'>        // We can abuse reference equality here for efficiency, since `splitOrFinish`
</span>792 <span style=''></span><span style='background: #AEF1AE'>        // returns `empty` on a capped stream.
</span>793 <span style=''></span><span style='background: #AEF1AE'>        case (_, rest) =&gt; rest != streamEmpty
</span>794 <span style=''></span><span style='background: #AEF1AE'>      }
</span>795 <span style=''></span><span style='background: #AEF1AE'>      .flatMap(
</span>796 <span style=''></span><span style='background: #AEF1AE'>        _.iterateWhileM { acc =&gt;
</span>797 <span style=''></span><span style='background: #AEF1AE'>          pullPartEvents0(acc).flatMap(
</span>798 <span style=''></span><span style='background: #AEF1AE'>            splitOrFinish(
</span>799 <span style=''></span><span style='background: #AEF1AE'>              DoubleCRLFBytesN,
</span>800 <span style=''></span><span style='background: #AEF1AE'>              _,
</span>801 <span style=''></span><span style='background: #AEF1AE'>              headerLimit,
</span>802 <span style=''></span><span style='background: #AEF1AE'>            )
</span>803 <span style=''></span><span style='background: #AEF1AE'>          )
</span>804 <span style=''></span><span style='background: #AEF1AE'>        } { case (_, rest) =&gt; rest != streamEmpty }.void
</span>805 <span style=''></span><span style='background: #AEF1AE'>      )</span><span style=''>
</span>806 <span style=''>  }
</span>807 <span style=''>
</span>808 <span style=''>  /** Pulls part events for a single part. */
</span>809 <span style=''>  private[this] def pullPartEvents[F[_]: Concurrent](
</span>810 <span style=''>      headerStream: Stream[F, Byte],
</span>811 <span style=''>      rest: Stream[F, Byte],
</span>812 <span style=''>      delimiterBytes: Array[Byte],
</span>813 <span style=''>  ): Pull[F, Event, Stream[F, Byte]] =
</span>814 <span style=''>    </span><span style='background: #AEF1AE'>Pull
</span>815 <span style=''></span><span style='background: #AEF1AE'>      .eval(parseHeaders(headerStream))
</span>816 <span style=''></span><span style='background: #AEF1AE'>      .flatMap(headers =&gt; Pull.output1(PartStart(headers): Event))
</span>817 <span style=''></span><span style='background: #AEF1AE'>      .productR(pullPartChunks(delimiterBytes, rest))
</span>818 <span style=''></span><span style='background: #AEF1AE'>      .flatMap { case rest =&gt;
</span>819 <span style=''></span><span style='background: #AEF1AE'>        // We hit a boundary, but the rest of the stream is empty
</span>820 <span style=''></span><span style='background: #AEF1AE'>        // and thus it's not a properly capped multipart body
</span>821 <span style=''></span><span style='background: #AEF1AE'>        if (rest == streamEmpty)
</span>822 <span style=''></span><span style='background: #AEF1AE'>          </span><span style='background: #F0ADAD'>Pull.raiseError[F](MalformedMessageBodyFailure(&quot;Part not terminated properly&quot;))</span><span style='background: #AEF1AE'>
</span>823 <span style=''></span><span style='background: #AEF1AE'>        else
</span>824 <span style=''></span><span style='background: #AEF1AE'>          Pull.output1(PartEnd).as(rest)
</span>825 <span style=''></span><span style='background: #AEF1AE'>      }</span><span style=''>
</span>826 <span style=''>
</span>827 <span style=''>  /** Split the stream on `delimiterBytes`, emitting the left part as `PartChunk` events. */
</span>828 <span style=''>  private[this] def pullPartChunks[F[_]: Concurrent](
</span>829 <span style=''>      delimiterBytes: Array[Byte],
</span>830 <span style=''>      stream: Stream[F, Byte],
</span>831 <span style=''>  ): Pull[F, PartChunk, Stream[F, Byte]] = {
</span>832 <span style=''>    def go(
</span>833 <span style=''>        s: Stream[F, Byte],
</span>834 <span style=''>        state: Int,
</span>835 <span style=''>        racc: Stream[F, Byte],
</span>836 <span style=''>    ): Pull[F, PartChunk, Stream[F, Byte]] =
</span>837 <span style=''>      if (</span><span style='background: #AEF1AE'>state == delimiterBytes.length</span><span style=''>)
</span>838 <span style=''>        </span><span style='background: #F0ADAD'>Pull.pure(racc ++ s)</span><span style=''>
</span>839 <span style=''>      else
</span>840 <span style=''>        </span><span style='background: #AEF1AE'>s.pull.uncons.flatMap {
</span>841 <span style=''></span><span style='background: #AEF1AE'>          case Some((chnk, rest)) =&gt;
</span>842 <span style=''></span><span style='background: #AEF1AE'>            val (ix, l, r) = splitOnChunk[F](delimiterBytes, state, chnk, Stream.empty, racc)
</span>843 <span style=''></span><span style='background: #AEF1AE'>            l.chunks.map(PartChunk(_)).pull.echo &gt;&gt; {
</span>844 <span style=''></span><span style='background: #AEF1AE'>              if (ix == delimiterBytes.length) Pull.pure(r ++ rest)
</span>845 <span style=''></span><span style='background: #AEF1AE'>              else go(rest, ix, r)
</span>846 <span style=''></span><span style='background: #AEF1AE'>            }
</span>847 <span style=''></span><span style='background: #AEF1AE'>          case None =&gt;
</span>848 <span style=''></span><span style='background: #AEF1AE'>            Pull.raiseError[F](MalformedMessageBodyFailure(&quot;Invalid boundary - partial boundary&quot;))
</span>849 <span style=''></span><span style='background: #AEF1AE'>        }</span><span style=''>
</span>850 <span style=''>
</span>851 <span style=''>    </span><span style='background: #AEF1AE'>go(stream, 0, Stream.empty)</span><span style=''>
</span>852 <span style=''>  }
</span>853 <span style=''>}
</span></pre>
          </div>
          <div class="tab-pane" id="statementlist">
            <table cellspacing="0" cellpadding="0" class="table statementlist">
      <tr>
        <th>Line</th>
        <th>Stmt Id</th>
        <th>Pos</th>
        <th>Tree</th>
        <th>Symbol</th>
        <th>Tests</th>
        <th>Code</th>
      </tr><tr>
        <td>
          38
        </td>
        <td>
          15753
        </td>
        <td>
          1171
          -
          1175
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          10
        </td>
      </tr><tr>
        <td>
          38
        </td>
        <td>
          19765
        </td>
        <td>
          1165
          -
          1169
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          13
        </td>
      </tr><tr>
        <td>
          38
        </td>
        <td>
          21930
        </td>
        <td>
          1153
          -
          1176
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.Array.apply
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          scala.Array.apply[Byte](13, 10)((ClassTag.Byte: scala.reflect.ClassTag[Byte]))
        </td>
      </tr><tr>
        <td>
          39
        </td>
        <td>
          20228
        </td>
        <td>
          1228
          -
          1232
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          13
        </td>
      </tr><tr>
        <td>
          39
        </td>
        <td>
          16537
        </td>
        <td>
          1234
          -
          1238
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          10
        </td>
      </tr><tr>
        <td>
          39
        </td>
        <td>
          18962
        </td>
        <td>
          1246
          -
          1250
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          10
        </td>
      </tr><tr>
        <td>
          39
        </td>
        <td>
          15199
        </td>
        <td>
          1216
          -
          1251
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.Array.apply
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          scala.Array.apply[Byte](13, 10, 13, 10)((ClassTag.Byte: scala.reflect.ClassTag[Byte]))
        </td>
      </tr><tr>
        <td>
          39
        </td>
        <td>
          22837
        </td>
        <td>
          1240
          -
          1244
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          13
        </td>
      </tr><tr>
        <td>
          40
        </td>
        <td>
          13134
        </td>
        <td>
          1301
          -
          1304
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          45
        </td>
      </tr><tr>
        <td>
          40
        </td>
        <td>
          19488
        </td>
        <td>
          1306
          -
          1309
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          45
        </td>
      </tr><tr>
        <td>
          40
        </td>
        <td>
          15772
        </td>
        <td>
          1289
          -
          1310
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.Array.apply
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          scala.Array.apply[Byte](45, 45)((ClassTag.Byte: scala.reflect.ClassTag[Byte]))
        </td>
      </tr><tr>
        <td>
          42
        </td>
        <td>
          22523
        </td>
        <td>
          1389
          -
          1421
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.String.getBytes
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          boundary.value.getBytes(&quot;UTF-8&quot;)
        </td>
      </tr><tr>
        <td>
          43
        </td>
        <td>
          20245
        </td>
        <td>
          1494
          -
          1508
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.multipart.MultipartParser.DashDashBytesN
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.DashDashBytesN
        </td>
      </tr><tr>
        <td>
          43
        </td>
        <td>
          16399
        </td>
        <td>
          1494
          -
          1513
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.ArrayOps.++
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.byteArrayOps(MultipartParser.this.DashDashBytesN).++[Byte](x$1)((ClassTag.Byte: scala.reflect.ClassTag[Byte]))
        </td>
      </tr><tr>
        <td>
          43
        </td>
        <td>
          22700
        </td>
        <td>
          1471
          -
          1514
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Function1.andThen
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.BoundaryBytesN.andThen[Array[Byte]](((x$1: Array[Byte]) =&gt; scala.Predef.byteArrayOps(MultipartParser.this.DashDashBytesN).++[Byte](x$1)((ClassTag.Byte: scala.reflect.ClassTag[Byte]))))
        </td>
      </tr><tr>
        <td>
          47
        </td>
        <td>
          13155
        </td>
        <td>
          1638
          -
          1666
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.ArrayOps.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.byteArrayOps(MultipartParser.this.CRLFBytesN).++[Byte](MultipartParser.this.DashDashBytesN)((ClassTag.Byte: scala.reflect.ClassTag[Byte]))
        </td>
      </tr><tr>
        <td>
          47
        </td>
        <td>
          15643
        </td>
        <td>
          1615
          -
          1672
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Function1.andThen
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.BoundaryBytesN.andThen[Array[Byte]](((x$2: Array[Byte]) =&gt; scala.Predef.byteArrayOps(scala.Predef.byteArrayOps(MultipartParser.this.CRLFBytesN).++[Byte](MultipartParser.this.DashDashBytesN)((ClassTag.Byte: scala.reflect.ClassTag[Byte]))).++[Byte](x$2)((ClassTag.Byte: scala.reflect.ClassTag[Byte]))))
        </td>
      </tr><tr>
        <td>
          47
        </td>
        <td>
          15457
        </td>
        <td>
          1652
          -
          1666
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.multipart.MultipartParser.DashDashBytesN
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.DashDashBytesN
        </td>
      </tr><tr>
        <td>
          47
        </td>
        <td>
          18977
        </td>
        <td>
          1638
          -
          1648
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.multipart.MultipartParser.CRLFBytesN
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.CRLFBytesN
        </td>
      </tr><tr>
        <td>
          47
        </td>
        <td>
          19509
        </td>
        <td>
          1638
          -
          1671
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.ArrayOps.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.byteArrayOps(scala.Predef.byteArrayOps(MultipartParser.this.CRLFBytesN).++[Byte](MultipartParser.this.DashDashBytesN)((ClassTag.Byte: scala.reflect.ClassTag[Byte]))).++[Byte](x$2)((ClassTag.Byte: scala.reflect.ClassTag[Byte]))
        </td>
      </tr><tr>
        <td>
          48
        </td>
        <td>
          22545
        </td>
        <td>
          1710
          -
          1713
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          '-'
        </td>
      </tr><tr>
        <td>
          48
        </td>
        <td>
          18697
        </td>
        <td>
          1710
          -
          1720
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Char.toByte
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          '-'.toByte
        </td>
      </tr><tr>
        <td>
          49
        </td>
        <td>
          16149
        </td>
        <td>
          1755
          -
          1767
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Stream.empty
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.empty
        </td>
      </tr><tr>
        <td>
          63
        </td>
        <td>
          22718
        </td>
        <td>
          2249
          -
          2284
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          org.http4s.multipart.MultipartParser.parseToPartsStream
        </td>
        <td>
          org.http4s.multipart.multipartparsersuite
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.parseToPartsStream[[_]F[_]](boundary, limit)(evidence$1)
        </td>
      </tr><tr>
        <td>
          64
        </td>
        <td>
          19216
        </td>
        <td>
          2296
          -
          2317
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.Vector.empty
        </td>
        <td>
          org.http4s.multipart.multipartparsersuite
        </td>
        <td style="background: #AEF1AE">
          scala.`package`.Vector.empty[org.http4s.multipart.Part[F]]
        </td>
      </tr><tr>
        <td>
          64
        </td>
        <td>
          15476
        </td>
        <td>
          2319
          -
          2325
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.SeqOps.:+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$3.:+[org.http4s.multipart.Part[F]](x$4)
        </td>
      </tr><tr>
        <td>
          65
        </td>
        <td>
          13415
        </td>
        <td>
          2338
          -
          2360
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.Multipart.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Multipart.apply[[_]F[_]](x$5, boundary)
        </td>
      </tr><tr>
        <td>
          65
        </td>
        <td>
          19383
        </td>
        <td>
          2231
          -
          2361
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.map
        </td>
        <td>
          org.http4s.multipart.multipartparsersuite
        </td>
        <td style="background: #AEF1AE">
          st.through[[x]F[x], org.http4s.multipart.Part[[_]F[_]]](MultipartParser.this.parseToPartsStream[[_]F[_]](boundary, limit)(evidence$1)).fold[scala.collection.immutable.Vector[org.http4s.multipart.Part[F]]](scala.`package`.Vector.empty[org.http4s.multipart.Part[F]])(((x$3: scala.collection.immutable.Vector[org.http4s.multipart.Part[F]], x$4: org.http4s.multipart.Part[[_]F[_]]) =&gt; x$3.:+[org.http4s.multipart.Part[F]](x$4))).map[org.http4s.multipart.Multipart[[_]F[_]]](((x$5: scala.collection.immutable.Vector[org.http4s.multipart.Part[F]]) =&gt; Multipart.apply[[_]F[_]](x$5, boundary)))
        </td>
      </tr><tr>
        <td>
          72
        </td>
        <td>
          15660
        </td>
        <td>
          2529
          -
          2560
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          org.http4s.multipart.MultipartParser.parseEvents
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.parseEvents[F](boundary, limit)(F)
        </td>
      </tr><tr>
        <td>
          75
        </td>
        <td>
          18860
        </td>
        <td>
          2511
          -
          3494
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.evalMapAccumulate
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          st.through[[x]F[x], org.http4s.multipart.MultipartParser.Event](MultipartParser.this.parseEvents[F](boundary, limit)(F)).evalMapAccumulate[F, Option[org.http4s.multipart.Part[F]], Option[org.http4s.multipart.Part[F]]](scala.None)(((acc: Option[org.http4s.multipart.Part[F]], item: org.http4s.multipart.MultipartParser.Event) =&gt; scala.Tuple2.apply[Option[org.http4s.multipart.Part[F]], org.http4s.multipart.MultipartParser.Event](acc, item) match {
  case (_1: Option[org.http4s.multipart.Part[F]], _2: org.http4s.multipart.MultipartParser.Event): (Option[org.http4s.multipart.Part[F]], org.http4s.multipart.MultipartParser.Event)(scala.None, (value: org.http4s.Headers): org.http4s.multipart.MultipartParser.PartStart((headers @ _))) =&gt; F.pure[(Option[org.http4s.multipart.Part[F]], Option[org.http4s.multipart.Part[F]])](scala.Tuple2.apply[Some[org.http4s.multipart.Part[[_]F[_]]], None.type](scala.Some.apply[org.http4s.multipart.Part[[_]F[_]]](Part.apply[[_]F[_]](headers, fs2.Stream.empty)), scala.None))
  case (_1: Option[org.http4s.multipart.Part[F]], _2: org.http4s.multipart.MultipartParser.Event): (Option[org.http4s.multipart.Part[F]], org.http4s.multipart.MultipartParser.Event)(scala.None, ((_: org.http4s.multipart.MultipartParser.PartChunk)| MultipartParser.this.PartEnd)) =&gt; F.raiseError[(Option[org.http4s.multipart.Part[F]], Option[org.http4s.multipart.Part[F]])](org.http4s.internal.`package`.bug(&quot;Missing PartStart&quot;))
  case (_1: Option[org.http4s.multipart.Part[F]], _2: org.http4s.multipart.MultipartParser.Event): (Option[org.http4s.multipart.Part[F]], org.http4s.multipart.MultipartParser.Event)((value: org.http4s.multipart.Part[F]): Some[org.http4s.multipart.Part[F]]((acc0 @ _)), (value: fs2.Chunk[Byte]): org.http4s.multipart.MultipartParser.PartChunk((chunk @ _))) =&gt; F.pure[(Option[org.http4s.multipart.Part[F]], Option[org.http4s.multipart.Part[F]])](scala.Tuple2.apply[Some[org.http4s.multipart.Part[[x]F[x]]], None.type](scala.Some.apply[org.http4s.multipart.Part[[x]F[x]]]({
    &lt;artifact&gt; val x$1: fs2.Stream[[x]F[x],Byte] @scala.reflect.internal.annotations.uncheckedBounds = acc0.body.++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](chunk));
    &lt;artifact&gt; val x$2: org.http4s.Headers = acc0.copy$default$1[Nothing];
    acc0.copy[[x]F[x]](x$2, x$1)
  }), scala.None))
  case (_1: Option[org.http4s.multipart.Part[F]], _2: org.http4s.multipart.MultipartParser.Event): (Option[org.http4s.multipart.Part[F]], org.http4s.multipart.MultipartParser.Event)((value: org.http4s.multipart.Part[F]): Some[org.http4s.multipart.Part[F]](_), MultipartParser.this.PartEnd) =&gt; F.pure[(Option[org.http4s.multipart.Part[F]], Option[org.http4s.multipart.Part[F]])](scala.Tuple2.apply[None.type, Option[org.http4s.multipart.Part[F]]](scala.None, acc))
  case (_1: Option[org.http4s.multipart.Part[F]], _2: org.http4s.multipart.MultipartParser.Event): (Option[org.http4s.multipart.Part[F]], org.http4s.multipart.MultipartParser.Event)((value: org.http4s.multipart.Part[F]): Some[org.http4s.multipart.Part[F]](_), (_: org.http4s.multipart.MultipartParser.PartStart)) =&gt; F.raiseError[(Option[org.http4s.multipart.Part[F]], Option[org.http4s.multipart.Part[F]])](org.http4s.internal.`package`.bug(&quot;Missing PartEnd&quot;))
}))
        </td>
      </tr><tr>
        <td>
          75
        </td>
        <td>
          15382
        </td>
        <td>
          2730
          -
          2730
        </td>
        <td>
          TypeApply
        </td>
        <td>
          fs2.Stream.functorFilterInstance
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Stream.functorFilterInstance[[_]F[_]]
        </td>
      </tr><tr>
        <td>
          75
        </td>
        <td>
          22406
        </td>
        <td>
          2724
          -
          2728
        </td>
        <td>
          Select
        </td>
        <td>
          scala.None
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          scala.None
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          16534
        </td>
        <td>
          2845
          -
          2872
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.Part.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Part.apply[[_]F[_]](headers, fs2.Stream.empty)
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          22587
        </td>
        <td>
          2840
          -
          2873
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[org.http4s.multipart.Part[[_]F[_]]](Part.apply[[_]F[_]](headers, fs2.Stream.empty))
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          19231
        </td>
        <td>
          2875
          -
          2879
        </td>
        <td>
          Select
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.None
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          15340
        </td>
        <td>
          2839
          -
          2880
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Some[org.http4s.multipart.Part[[_]F[_]]], None.type](scala.Some.apply[org.http4s.multipart.Part[[_]F[_]]](Part.apply[[_]F[_]](headers, fs2.Stream.empty)), scala.None)
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          18710
        </td>
        <td>
          2859
          -
          2871
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Stream.empty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.empty
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          13129
        </td>
        <td>
          2832
          -
          2881
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.Applicative.pure
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          F.pure[(Option[org.http4s.multipart.Part[F]], Option[org.http4s.multipart.Part[F]])](scala.Tuple2.apply[Some[org.http4s.multipart.Part[[_]F[_]]], None.type](scala.Some.apply[org.http4s.multipart.Part[[_]F[_]]](Part.apply[[_]F[_]](headers, fs2.Stream.empty)), scala.None))
        </td>
      </tr><tr>
        <td>
          81
        </td>
        <td>
          19778
        </td>
        <td>
          3031
          -
          3055
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.internal.bug
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.http4s.internal.`package`.bug(&quot;Missing PartStart&quot;)
        </td>
      </tr><tr>
        <td>
          81
        </td>
        <td>
          15911
        </td>
        <td>
          3018
          -
          3056
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.ApplicativeError.raiseError
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          F.raiseError[(Option[org.http4s.multipart.Part[F]], Option[org.http4s.multipart.Part[F]])](org.http4s.internal.`package`.bug(&quot;Missing PartStart&quot;))
        </td>
      </tr><tr>
        <td>
          83
        </td>
        <td>
          22976
        </td>
        <td>
          3131
          -
          3181
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.Part.copy
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          acc0.copy[[x]F[x]](x$2, x$1)
        </td>
      </tr><tr>
        <td>
          83
        </td>
        <td>
          15359
        </td>
        <td>
          3184
          -
          3188
        </td>
        <td>
          Select
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.None
        </td>
      </tr><tr>
        <td>
          83
        </td>
        <td>
          19118
        </td>
        <td>
          3126
          -
          3182
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[org.http4s.multipart.Part[[x]F[x]]]({
  &lt;artifact&gt; val x$1: fs2.Stream[[x]F[x],Byte] @scala.reflect.internal.annotations.uncheckedBounds = acc0.body.++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](chunk));
  &lt;artifact&gt; val x$2: org.http4s.Headers = acc0.copy$default$1[Nothing];
  acc0.copy[[x]F[x]](x$2, x$1)
})
        </td>
      </tr><tr>
        <td>
          83
        </td>
        <td>
          16393
        </td>
        <td>
          3136
          -
          3136
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.http4s.multipart.Part.copy$default$1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          acc0.copy$default$1[Nothing]
        </td>
      </tr><tr>
        <td>
          83
        </td>
        <td>
          19650
        </td>
        <td>
          3118
          -
          3190
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.Applicative.pure
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          F.pure[(Option[org.http4s.multipart.Part[F]], Option[org.http4s.multipart.Part[F]])](scala.Tuple2.apply[Some[org.http4s.multipart.Part[[x]F[x]]], None.type](scala.Some.apply[org.http4s.multipart.Part[[x]F[x]]]({
  &lt;artifact&gt; val x$1: fs2.Stream[[x]F[x],Byte] @scala.reflect.internal.annotations.uncheckedBounds = acc0.body.++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](chunk));
  &lt;artifact&gt; val x$2: org.http4s.Headers = acc0.copy$default$1[Nothing];
  acc0.copy[[x]F[x]](x$2, x$1)
}), scala.None))
        </td>
      </tr><tr>
        <td>
          83
        </td>
        <td>
          22424
        </td>
        <td>
          3161
          -
          3180
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.chunk
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.chunk[[x]fs2.Pure[x], Byte](chunk)
        </td>
      </tr><tr>
        <td>
          83
        </td>
        <td>
          21670
        </td>
        <td>
          3125
          -
          3189
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Some[org.http4s.multipart.Part[[x]F[x]]], None.type](scala.Some.apply[org.http4s.multipart.Part[[x]F[x]]]({
  &lt;artifact&gt; val x$1: fs2.Stream[[x]F[x],Byte] @scala.reflect.internal.annotations.uncheckedBounds = acc0.body.++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](chunk));
  &lt;artifact&gt; val x$2: org.http4s.Headers = acc0.copy$default$1[Nothing];
  acc0.copy[[x]F[x]](x$2, x$1)
}), scala.None)
        </td>
      </tr><tr>
        <td>
          83
        </td>
        <td>
          18078
        </td>
        <td>
          3148
          -
          3180
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          acc0.body.++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](chunk))
        </td>
      </tr><tr>
        <td>
          86
        </td>
        <td>
          22294
        </td>
        <td>
          3298
          -
          3309
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[None.type, Option[org.http4s.multipart.Part[F]]](scala.None, acc)
        </td>
      </tr><tr>
        <td>
          86
        </td>
        <td>
          15640
        </td>
        <td>
          3299
          -
          3303
        </td>
        <td>
          Select
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.None
        </td>
      </tr><tr>
        <td>
          86
        </td>
        <td>
          18311
        </td>
        <td>
          3291
          -
          3310
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.Applicative.pure
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          F.pure[(Option[org.http4s.multipart.Part[F]], Option[org.http4s.multipart.Part[F]])](scala.Tuple2.apply[None.type, Option[org.http4s.multipart.Part[F]]](scala.None, acc))
        </td>
      </tr><tr>
        <td>
          89
        </td>
        <td>
          22862
        </td>
        <td>
          3440
          -
          3476
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.ApplicativeError.raiseError
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          F.raiseError[(Option[org.http4s.multipart.Part[F]], Option[org.http4s.multipart.Part[F]])](org.http4s.internal.`package`.bug(&quot;Missing PartEnd&quot;))
        </td>
      </tr><tr>
        <td>
          89
        </td>
        <td>
          16417
        </td>
        <td>
          3453
          -
          3475
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.internal.bug
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.http4s.internal.`package`.bug(&quot;Missing PartEnd&quot;)
        </td>
      </tr><tr>
        <td>
          92
        </td>
        <td>
          19671
        </td>
        <td>
          2511
          -
          3517
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.FunctorFilter.Ops.mapFilter
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          cats.syntax.`package`.all.toFunctorFilterOps[[+O]fs2.Stream[F,O], (Option[org.http4s.multipart.Part[F]], Option[org.http4s.multipart.Part[F]])](st.through[[x]F[x], org.http4s.multipart.MultipartParser.Event](MultipartParser.this.parseEvents[F](boundary, limit)(F)).evalMapAccumulate[F, Option[org.http4s.multipart.Part[F]], Option[org.http4s.multipart.Part[F]]](scala.None)(((acc: Option[org.http4s.multipart.Part[F]], item: org.http4s.multipart.MultipartParser.Event) =&gt; scala.Tuple2.apply[Option[org.http4s.multipart.Part[F]], org.http4s.multipart.MultipartParser.Event](acc, item) match {
  case (_1: Option[org.http4s.multipart.Part[F]], _2: org.http4s.multipart.MultipartParser.Event): (Option[org.http4s.multipart.Part[F]], org.http4s.multipart.MultipartParser.Event)(scala.None, (value: org.http4s.Headers): org.http4s.multipart.MultipartParser.PartStart((headers @ _))) =&gt; F.pure[(Option[org.http4s.multipart.Part[F]], Option[org.http4s.multipart.Part[F]])](scala.Tuple2.apply[Some[org.http4s.multipart.Part[[_]F[_]]], None.type](scala.Some.apply[org.http4s.multipart.Part[[_]F[_]]](Part.apply[[_]F[_]](headers, fs2.Stream.empty)), scala.None))
  case (_1: Option[org.http4s.multipart.Part[F]], _2: org.http4s.multipart.MultipartParser.Event): (Option[org.http4s.multipart.Part[F]], org.http4s.multipart.MultipartParser.Event)(scala.None, ((_: org.http4s.multipart.MultipartParser.PartChunk)| MultipartParser.this.PartEnd)) =&gt; F.raiseError[(Option[org.http4s.multipart.Part[F]], Option[org.http4s.multipart.Part[F]])](org.http4s.internal.`package`.bug(&quot;Missing PartStart&quot;))
  case (_1: Option[org.http4s.multipart.Part[F]], _2: org.http4s.multipart.MultipartParser.Event): (Option[org.http4s.multipart.Part[F]], org.http4s.multipart.MultipartParser.Event)((value: org.http4s.multipart.Part[F]): Some[org.http4s.multipart.Part[F]]((acc0 @ _)), (value: fs2.Chunk[Byte]): org.http4s.multipart.MultipartParser.PartChunk((chunk @ _))) =&gt; F.pure[(Option[org.http4s.multipart.Part[F]], Option[org.http4s.multipart.Part[F]])](scala.Tuple2.apply[Some[org.http4s.multipart.Part[[x]F[x]]], None.type](scala.Some.apply[org.http4s.multipart.Part[[x]F[x]]]({
    &lt;artifact&gt; val x$1: fs2.Stream[[x]F[x],Byte] @scala.reflect.internal.annotations.uncheckedBounds = acc0.body.++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](chunk));
    &lt;artifact&gt; val x$2: org.http4s.Headers = acc0.copy$default$1[Nothing];
    acc0.copy[[x]F[x]](x$2, x$1)
  }), scala.None))
  case (_1: Option[org.http4s.multipart.Part[F]], _2: org.http4s.multipart.MultipartParser.Event): (Option[org.http4s.multipart.Part[F]], org.http4s.multipart.MultipartParser.Event)((value: org.http4s.multipart.Part[F]): Some[org.http4s.multipart.Part[F]](_), MultipartParser.this.PartEnd) =&gt; F.pure[(Option[org.http4s.multipart.Part[F]], Option[org.http4s.multipart.Part[F]])](scala.Tuple2.apply[None.type, Option[org.http4s.multipart.Part[F]]](scala.None, acc))
  case (_1: Option[org.http4s.multipart.Part[F]], _2: org.http4s.multipart.MultipartParser.Event): (Option[org.http4s.multipart.Part[F]], org.http4s.multipart.MultipartParser.Event)((value: org.http4s.multipart.Part[F]): Some[org.http4s.multipart.Part[F]](_), (_: org.http4s.multipart.MultipartParser.PartStart)) =&gt; F.raiseError[(Option[org.http4s.multipart.Part[F]], Option[org.http4s.multipart.Part[F]])](org.http4s.internal.`package`.bug(&quot;Missing PartEnd&quot;))
})))(fs2.this.Stream.functorFilterInstance[[_]F[_]]).mapFilter[org.http4s.multipart.Part[F]](((x$6: (Option[org.http4s.multipart.Part[F]], Option[org.http4s.multipart.Part[F]])) =&gt; x$6._2))
        </td>
      </tr><tr>
        <td>
          92
        </td>
        <td>
          21536
        </td>
        <td>
          3512
          -
          3516
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$6._2
        </td>
      </tr><tr>
        <td>
          100
        </td>
        <td>
          15498
        </td>
        <td>
          3674
          -
          3675
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          102
        </td>
        <td>
          22040
        </td>
        <td>
          3716
          -
          3729
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Array.length
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          values.length
        </td>
      </tr><tr>
        <td>
          103
        </td>
        <td>
          18604
        </td>
        <td>
          3734
          -
          3734
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          103
        </td>
        <td>
          22285
        </td>
        <td>
          3734
          -
          3734
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          103
        </td>
        <td>
          18331
        </td>
        <td>
          3764
          -
          3770
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Chunk.size
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          c.size
        </td>
      </tr><tr>
        <td>
          103
        </td>
        <td>
          14473
        </td>
        <td>
          3760
          -
          3770
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          i.&lt;(c.size)
        </td>
      </tr><tr>
        <td>
          103
        </td>
        <td>
          19921
        </td>
        <td>
          3772
          -
          3772
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.while$1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          while$1()
        </td>
      </tr><tr>
        <td>
          103
        </td>
        <td>
          15536
        </td>
        <td>
          3772
          -
          3941
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  {
    if (c.apply(i).==(values.apply(currState)))
      currState = currState.+(1)
    else
      if (c.apply(i).==(values.apply(0)))
        currState = 1
      else
        currState = 0;
    i = i.+(1)
  };
  while$1()
}
        </td>
      </tr><tr>
        <td>
          103
        </td>
        <td>
          22582
        </td>
        <td>
          3741
          -
          3770
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          currState.&lt;(len).&amp;&amp;(i.&lt;(c.size))
        </td>
      </tr><tr>
        <td>
          104
        </td>
        <td>
          18732
        </td>
        <td>
          3792
          -
          3809
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Array.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          values.apply(currState)
        </td>
      </tr><tr>
        <td>
          104
        </td>
        <td>
          15331
        </td>
        <td>
          3784
          -
          3809
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Byte.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          c.apply(i).==(values.apply(currState))
        </td>
      </tr><tr>
        <td>
          105
        </td>
        <td>
          21558
        </td>
        <td>
          3819
          -
          3833
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          currState.+(1)
        </td>
      </tr><tr>
        <td>
          105
        </td>
        <td>
          19536
        </td>
        <td>
          3819
          -
          3833
        </td>
        <td>
          Assign
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          currState = currState.+(1)
        </td>
      </tr><tr>
        <td>
          106
        </td>
        <td>
          15352
        </td>
        <td>
          3845
          -
          3922
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (c.apply(i).==(values.apply(0)))
  currState = 1
else
  currState = 0
        </td>
      </tr><tr>
        <td>
          106
        </td>
        <td>
          22057
        </td>
        <td>
          3849
          -
          3866
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Byte.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          c.apply(i).==(values.apply(0))
        </td>
      </tr><tr>
        <td>
          106
        </td>
        <td>
          15516
        </td>
        <td>
          3857
          -
          3866
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Array.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          values.apply(0)
        </td>
      </tr><tr>
        <td>
          107
        </td>
        <td>
          14495
        </td>
        <td>
          3876
          -
          3889
        </td>
        <td>
          Assign
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          currState = 1
        </td>
      </tr><tr>
        <td>
          107
        </td>
        <td>
          18581
        </td>
        <td>
          3888
          -
          3889
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          1
        </td>
      </tr><tr>
        <td>
          109
        </td>
        <td>
          18750
        </td>
        <td>
          3909
          -
          3922
        </td>
        <td>
          Assign
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          currState = 0
        </td>
      </tr><tr>
        <td>
          109
        </td>
        <td>
          23104
        </td>
        <td>
          3921
          -
          3922
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          110
        </td>
        <td>
          21797
        </td>
        <td>
          3929
          -
          3935
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          i.+(1)
        </td>
      </tr><tr>
        <td>
          113
        </td>
        <td>
          14726
        </td>
        <td>
          3951
          -
          3965
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          currState.==(0)
        </td>
      </tr><tr>
        <td>
          114
        </td>
        <td>
          23117
        </td>
        <td>
          3974
          -
          3975
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          114
        </td>
        <td>
          18771
        </td>
        <td>
          3977
          -
          3989
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Stream.empty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.empty
        </td>
      </tr><tr>
        <td>
          114
        </td>
        <td>
          21815
        </td>
        <td>
          3973
          -
          3990
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Int, fs2.Stream[fs2.Pure,fs2.INothing]](0, fs2.Stream.empty)
        </td>
      </tr><tr>
        <td>
          114
        </td>
        <td>
          15211
        </td>
        <td>
          3973
          -
          3990
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Int, fs2.Stream[fs2.Pure,fs2.INothing]](0, fs2.Stream.empty)
        </td>
      </tr><tr>
        <td>
          115
        </td>
        <td>
          21698
        </td>
        <td>
          4000
          -
          4105
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (currState.==(len))
  scala.Tuple2.apply[Int, fs2.Stream[[x]fs2.Pure[x],Byte]](currState, fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.drop(i)))
else
  scala.Tuple2.apply[Int, fs2.Stream[fs2.Pure,fs2.INothing]](currState, fs2.Stream.empty)
        </td>
      </tr><tr>
        <td>
          115
        </td>
        <td>
          17690
        </td>
        <td>
          4004
          -
          4020
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          currState.==(len)
        </td>
      </tr><tr>
        <td>
          116
        </td>
        <td>
          18472
        </td>
        <td>
          4028
          -
          4064
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Int, fs2.Stream[[x]fs2.Pure[x],Byte]](currState, fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.drop(i)))
        </td>
      </tr><tr>
        <td>
          116
        </td>
        <td>
          16049
        </td>
        <td>
          4053
          -
          4062
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Chunk.drop
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          c.drop(i)
        </td>
      </tr><tr>
        <td>
          116
        </td>
        <td>
          22299
        </td>
        <td>
          4040
          -
          4063
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.chunk
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.drop(i))
        </td>
      </tr><tr>
        <td>
          116
        </td>
        <td>
          14466
        </td>
        <td>
          4028
          -
          4064
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Int, fs2.Stream[[x]fs2.Pure[x],Byte]](currState, fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.drop(i)))
        </td>
      </tr><tr>
        <td>
          118
        </td>
        <td>
          19019
        </td>
        <td>
          4080
          -
          4105
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Int, fs2.Stream[fs2.Pure,fs2.INothing]](currState, fs2.Stream.empty)
        </td>
      </tr><tr>
        <td>
          118
        </td>
        <td>
          15233
        </td>
        <td>
          4080
          -
          4105
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Int, fs2.Stream[fs2.Pure,fs2.INothing]](currState, fs2.Stream.empty)
        </td>
      </tr><tr>
        <td>
          118
        </td>
        <td>
          22878
        </td>
        <td>
          4092
          -
          4104
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Stream.empty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.empty
        </td>
      </tr><tr>
        <td>
          142
        </td>
        <td>
          18747
        </td>
        <td>
          4836
          -
          4988
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple3.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple3.apply[Int, fs2.Stream[[x]F[x],Byte], fs2.Stream[[x]fs2.Pure[x],Byte]](sti, acc.++[[x]F[x], Byte](carry).++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.take(i.-(sti)))), fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.drop(i)))
        </td>
      </tr><tr>
        <td>
          142
        </td>
        <td>
          15107
        </td>
        <td>
          4836
          -
          4988
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Tuple3.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple3.apply[Int, fs2.Stream[[x]F[x],Byte], fs2.Stream[[x]fs2.Pure[x],Byte]](sti, acc.++[[x]F[x], Byte](carry).++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.take(i.-(sti)))), fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.drop(i)))
        </td>
      </tr><tr>
        <td>
          145
        </td>
        <td>
          22190
        </td>
        <td>
          4917
          -
          4946
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.chunk
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.take(i.-(sti)))
        </td>
      </tr><tr>
        <td>
          145
        </td>
        <td>
          18487
        </td>
        <td>
          4901
          -
          4946
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          acc.++[[x]F[x], Byte](carry).++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.take(i.-(sti))))
        </td>
      </tr><tr>
        <td>
          145
        </td>
        <td>
          15809
        </td>
        <td>
          4930
          -
          4945
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Chunk.take
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          c.take(i.-(sti))
        </td>
      </tr><tr>
        <td>
          145
        </td>
        <td>
          17711
        </td>
        <td>
          4937
          -
          4944
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          i.-(sti)
        </td>
      </tr><tr>
        <td>
          146
        </td>
        <td>
          22739
        </td>
        <td>
          4956
          -
          4979
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.chunk
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.drop(i))
        </td>
      </tr><tr>
        <td>
          146
        </td>
        <td>
          14484
        </td>
        <td>
          4969
          -
          4978
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Chunk.drop
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          c.drop(i)
        </td>
      </tr><tr>
        <td>
          149
        </td>
        <td>
          16028
        </td>
        <td>
          5028
          -
          5151
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple3.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple3.apply[Int, fs2.Stream[F,Byte], fs2.Stream[[x]fs2.Pure[x],Byte]](sti, acc, fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.drop(i)))
        </td>
      </tr><tr>
        <td>
          149
        </td>
        <td>
          21942
        </td>
        <td>
          5028
          -
          5151
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Tuple3.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple3.apply[Int, fs2.Stream[F,Byte], fs2.Stream[[x]fs2.Pure[x],Byte]](sti, acc, fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.drop(i)))
        </td>
      </tr><tr>
        <td>
          152
        </td>
        <td>
          17731
        </td>
        <td>
          5119
          -
          5142
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.chunk
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.drop(i))
        </td>
      </tr><tr>
        <td>
          152
        </td>
        <td>
          21414
        </td>
        <td>
          5132
          -
          5141
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Chunk.drop
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          c.drop(i)
        </td>
      </tr><tr>
        <td>
          169
        </td>
        <td>
          18353
        </td>
        <td>
          5642
          -
          5655
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          i.-(currState)
        </td>
      </tr><tr>
        <td>
          170
        </td>
        <td>
          16044
        </td>
        <td>
          5679
          -
          5808
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$7: (fs2.Chunk[Byte], fs2.Chunk[Byte]) = (c.splitAt(ixx): (fs2.Chunk[Byte], fs2.Chunk[Byte]) @unchecked) match {
    case (_1: fs2.Chunk[Byte], _2: fs2.Chunk[Byte]): (fs2.Chunk[Byte], fs2.Chunk[Byte])((lchunk @ _), (rchunk @ _)) =&gt; scala.Tuple2.apply[fs2.Chunk[Byte], fs2.Chunk[Byte]](lchunk, rchunk)
  };
  val lchunk: fs2.Chunk[Byte] = x$7._1;
  val rchunk: fs2.Chunk[Byte] = x$7._2;
  scala.Tuple3.apply[Int, fs2.Stream[[x]F[x],Byte], fs2.Stream[[x]fs2.Pure[x],Byte]](currState, acc.++[[x]F[x], Byte](carry).++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](lchunk)), fs2.Stream.chunk[[x]fs2.Pure[x], Byte](rchunk))
}
        </td>
      </tr><tr>
        <td>
          171
        </td>
        <td>
          20927
        </td>
        <td>
          5700
          -
          5700
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$7._2
        </td>
      </tr><tr>
        <td>
          171
        </td>
        <td>
          14346
        </td>
        <td>
          5692
          -
          5692
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$7._1
        </td>
      </tr><tr>
        <td>
          172
        </td>
        <td>
          17598
        </td>
        <td>
          5731
          -
          5802
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple3.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple3.apply[Int, fs2.Stream[[x]F[x],Byte], fs2.Stream[[x]fs2.Pure[x],Byte]](currState, acc.++[[x]F[x], Byte](carry).++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](lchunk)), fs2.Stream.chunk[[x]fs2.Pure[x], Byte](rchunk))
        </td>
      </tr><tr>
        <td>
          172
        </td>
        <td>
          21432
        </td>
        <td>
          5781
          -
          5801
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.chunk
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.chunk[[x]fs2.Pure[x], Byte](rchunk)
        </td>
      </tr><tr>
        <td>
          172
        </td>
        <td>
          14861
        </td>
        <td>
          5743
          -
          5779
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          acc.++[[x]F[x], Byte](carry).++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](lchunk))
        </td>
      </tr><tr>
        <td>
          172
        </td>
        <td>
          19248
        </td>
        <td>
          5759
          -
          5779
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.chunk
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.chunk[[x]fs2.Pure[x], Byte](lchunk)
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          14368
        </td>
        <td>
          5820
          -
          5862
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple3.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple3.apply[Int, fs2.Stream[F,Byte], fs2.Stream[[x]F[x],Byte]](currState, acc, carry.++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c)))
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          18462
        </td>
        <td>
          5837
          -
          5861
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          carry.++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c))
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          22445
        </td>
        <td>
          5846
          -
          5861
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.chunk
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c)
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          20815
        </td>
        <td>
          5820
          -
          5862
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Tuple3.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple3.apply[Int, fs2.Stream[F,Byte], fs2.Stream[[x]F[x],Byte]](currState, acc, carry.++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c)))
        </td>
      </tr><tr>
        <td>
          197
        </td>
        <td>
          19268
        </td>
        <td>
          6658
          -
          6659
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          199
        </td>
        <td>
          15381
        </td>
        <td>
          6700
          -
          6713
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Array.length
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          values.length
        </td>
      </tr><tr>
        <td>
          200
        </td>
        <td>
          20784
        </td>
        <td>
          6756
          -
          6756
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.while$2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          while$2()
        </td>
      </tr><tr>
        <td>
          200
        </td>
        <td>
          14076
        </td>
        <td>
          6725
          -
          6754
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          currState.&lt;(len).&amp;&amp;(i.&lt;(c.size))
        </td>
      </tr><tr>
        <td>
          200
        </td>
        <td>
          21687
        </td>
        <td>
          6748
          -
          6754
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Chunk.size
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          c.size
        </td>
      </tr><tr>
        <td>
          200
        </td>
        <td>
          21573
        </td>
        <td>
          6718
          -
          6718
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          200
        </td>
        <td>
          15116
        </td>
        <td>
          6718
          -
          6718
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          200
        </td>
        <td>
          17619
        </td>
        <td>
          6744
          -
          6754
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          i.&lt;(c.size)
        </td>
      </tr><tr>
        <td>
          200
        </td>
        <td>
          19158
        </td>
        <td>
          6756
          -
          6925
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  {
    if (c.apply(i).==(values.apply(currState)))
      currState = currState.+(1)
    else
      if (c.apply(i).==(values.apply(0)))
        currState = 1
      else
        currState = 0;
    i = i.+(1)
  };
  while$2()
}
        </td>
      </tr><tr>
        <td>
          201
        </td>
        <td>
          22467
        </td>
        <td>
          6776
          -
          6793
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Array.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          values.apply(currState)
        </td>
      </tr><tr>
        <td>
          201
        </td>
        <td>
          18483
        </td>
        <td>
          6768
          -
          6793
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Byte.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          c.apply(i).==(values.apply(currState))
        </td>
      </tr><tr>
        <td>
          202
        </td>
        <td>
          21177
        </td>
        <td>
          6803
          -
          6817
        </td>
        <td>
          Assign
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          currState = currState.+(1)
        </td>
      </tr><tr>
        <td>
          202
        </td>
        <td>
          14624
        </td>
        <td>
          6803
          -
          6817
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          currState.+(1)
        </td>
      </tr><tr>
        <td>
          203
        </td>
        <td>
          19145
        </td>
        <td>
          6841
          -
          6850
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Array.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          values.apply(0)
        </td>
      </tr><tr>
        <td>
          203
        </td>
        <td>
          18345
        </td>
        <td>
          6829
          -
          6906
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (c.apply(i).==(values.apply(0)))
  currState = 1
else
  currState = 0
        </td>
      </tr><tr>
        <td>
          203
        </td>
        <td>
          15100
        </td>
        <td>
          6833
          -
          6850
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Byte.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          c.apply(i).==(values.apply(0))
        </td>
      </tr><tr>
        <td>
          204
        </td>
        <td>
          21708
        </td>
        <td>
          6872
          -
          6873
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1
        </td>
      </tr><tr>
        <td>
          204
        </td>
        <td>
          17854
        </td>
        <td>
          6860
          -
          6873
        </td>
        <td>
          Assign
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          currState = 1
        </td>
      </tr><tr>
        <td>
          206
        </td>
        <td>
          22486
        </td>
        <td>
          6893
          -
          6906
        </td>
        <td>
          Assign
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          currState = 0
        </td>
      </tr><tr>
        <td>
          206
        </td>
        <td>
          14094
        </td>
        <td>
          6905
          -
          6906
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          207
        </td>
        <td>
          14641
        </td>
        <td>
          6913
          -
          6919
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          i.+(1)
        </td>
      </tr><tr>
        <td>
          213
        </td>
        <td>
          17590
        </td>
        <td>
          7100
          -
          7125
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          i.+(state).-(currState).&gt;(0)
        </td>
      </tr><tr>
        <td>
          215
        </td>
        <td>
          13696
        </td>
        <td>
          7135
          -
          7149
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          currState.==(0)
        </td>
      </tr><tr>
        <td>
          216
        </td>
        <td>
          17031
        </td>
        <td>
          7157
          -
          7207
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple3.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple3.apply[Int, fs2.Stream[[x]F[x],Byte], fs2.Stream[fs2.Pure,fs2.INothing]](0, acc.++[[x]F[x], Byte](carry).++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c)), fs2.Stream.empty)
        </td>
      </tr><tr>
        <td>
          216
        </td>
        <td>
          20805
        </td>
        <td>
          7194
          -
          7206
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Stream.empty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.empty
        </td>
      </tr><tr>
        <td>
          216
        </td>
        <td>
          22440
        </td>
        <td>
          7158
          -
          7159
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          216
        </td>
        <td>
          15376
        </td>
        <td>
          7157
          -
          7207
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Tuple3.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple3.apply[Int, fs2.Stream[[x]F[x],Byte], fs2.Stream[fs2.Pure,fs2.INothing]](0, acc.++[[x]F[x], Byte](carry).++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c)), fs2.Stream.empty)
        </td>
      </tr><tr>
        <td>
          216
        </td>
        <td>
          18362
        </td>
        <td>
          7177
          -
          7192
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.chunk
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c)
        </td>
      </tr><tr>
        <td>
          216
        </td>
        <td>
          14516
        </td>
        <td>
          7161
          -
          7192
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          acc.++[[x]F[x], Byte](carry).++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c))
        </td>
      </tr><tr>
        <td>
          217
        </td>
        <td>
          21591
        </td>
        <td>
          7221
          -
          7237
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          currState.==(len)
        </td>
      </tr><tr>
        <td>
          217
        </td>
        <td>
          14235
        </td>
        <td>
          7217
          -
          7384
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (currState.==(len))
  MultipartParser.this.splitCompleteMatch[[_]F[_]](middleChunked, currState, i, acc, carry, c)
else
  MultipartParser.this.splitPartialMatch[[_]F[_]](middleChunked, currState, i, acc, carry, c)
        </td>
      </tr><tr>
        <td>
          218
        </td>
        <td>
          13713
        </td>
        <td>
          7245
          -
          7307
        </td>
        <td>
          Block
        </td>
        <td>
          org.http4s.multipart.MultipartParser.splitCompleteMatch
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.splitCompleteMatch[[_]F[_]](middleChunked, currState, i, acc, carry, c)
        </td>
      </tr><tr>
        <td>
          218
        </td>
        <td>
          17459
        </td>
        <td>
          7245
          -
          7307
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.splitCompleteMatch
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.splitCompleteMatch[[_]F[_]](middleChunked, currState, i, acc, carry, c)
        </td>
      </tr><tr>
        <td>
          220
        </td>
        <td>
          22464
        </td>
        <td>
          7323
          -
          7384
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.splitPartialMatch
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.splitPartialMatch[[_]F[_]](middleChunked, currState, i, acc, carry, c)
        </td>
      </tr><tr>
        <td>
          220
        </td>
        <td>
          18624
        </td>
        <td>
          7323
          -
          7384
        </td>
        <td>
          Block
        </td>
        <td>
          org.http4s.multipart.MultipartParser.splitPartialMatch
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.splitPartialMatch[[_]F[_]](middleChunked, currState, i, acc, carry, c)
        </td>
      </tr><tr>
        <td>
          245
        </td>
        <td>
          20670
        </td>
        <td>
          8315
          -
          8316
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          245
        </td>
        <td>
          13729
        </td>
        <td>
          8312
          -
          8350
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          c1.apply(0).==(MultipartParser.this.dashByte).&amp;&amp;(c2.apply(0).==(MultipartParser.this.dashByte))
        </td>
      </tr><tr>
        <td>
          245
        </td>
        <td>
          15397
        </td>
        <td>
          8336
          -
          8337
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          245
        </td>
        <td>
          21830
        </td>
        <td>
          8342
          -
          8350
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.multipart.MultipartParser.dashByte
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.dashByte
        </td>
      </tr><tr>
        <td>
          245
        </td>
        <td>
          17299
        </td>
        <td>
          8321
          -
          8329
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.multipart.MultipartParser.dashByte
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.dashByte
        </td>
      </tr><tr>
        <td>
          245
        </td>
        <td>
          17471
        </td>
        <td>
          8333
          -
          8350
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Byte.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          c2.apply(0).==(MultipartParser.this.dashByte)
        </td>
      </tr><tr>
        <td>
          247
        </td>
        <td>
          14486
        </td>
        <td>
          8415
          -
          8433
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Stream.CompileOps.drain
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          rest.compile[[x]F[x], [x]F[x], Byte](fs2.this.Compiler.target[[x]F[x]](Compiler.this.Target.forConcurrent[[x]F[x]](evidence$2))).drain
        </td>
      </tr><tr>
        <td>
          247
        </td>
        <td>
          22318
        </td>
        <td>
          8420
          -
          8420
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.Compiler.Target.forConcurrent
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Compiler.this.Target.forConcurrent[[x]F[x]](evidence$2)
        </td>
      </tr><tr>
        <td>
          247
        </td>
        <td>
          17317
        </td>
        <td>
          8414
          -
          8414
        </td>
        <td>
          TypeApply
        </td>
        <td>
          fs2.PullLowPriority.monadErrorInstance
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Pull.monadErrorInstance[[_]F[_], fs2.INothing]
        </td>
      </tr><tr>
        <td>
          247
        </td>
        <td>
          20543
        </td>
        <td>
          8405
          -
          8487
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.Apply.Ops.*&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          cats.syntax.`package`.all.catsSyntaxApply[[+R]fs2.Pull[F,fs2.INothing,R], Unit](fs2.Pull.eval[F, Unit](rest.compile[[x]F[x], [x]F[x], Byte](fs2.this.Compiler.target[[x]F[x]](Compiler.this.Target.forConcurrent[[x]F[x]](evidence$2))).drain))(fs2.this.Pull.monadErrorInstance[[_]F[_], fs2.INothing]).*&gt;[(fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing])](fs2.Pull.pure[Nothing, (fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing])](scala.Tuple2.apply[fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing]](MultipartParser.this.streamEmpty, MultipartParser.this.streamEmpty)))
        </td>
      </tr><tr>
        <td>
          247
        </td>
        <td>
          18644
        </td>
        <td>
          8420
          -
          8420
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.CompilerLowPriority1.target
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Compiler.target[[x]F[x]](Compiler.this.Target.forConcurrent[[x]F[x]](evidence$2))
        </td>
      </tr><tr>
        <td>
          247
        </td>
        <td>
          18512
        </td>
        <td>
          8405
          -
          8487
        </td>
        <td>
          Block
        </td>
        <td>
          cats.Apply.Ops.*&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          cats.syntax.`package`.all.catsSyntaxApply[[+R]fs2.Pull[F,fs2.INothing,R], Unit](fs2.Pull.eval[F, Unit](rest.compile[[x]F[x], [x]F[x], Byte](fs2.this.Compiler.target[[x]F[x]](Compiler.this.Target.forConcurrent[[x]F[x]](evidence$2))).drain))(fs2.this.Pull.monadErrorInstance[[_]F[_], fs2.INothing]).*&gt;[(fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing])](fs2.Pull.pure[Nothing, (fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing])](scala.Tuple2.apply[fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing]](MultipartParser.this.streamEmpty, MultipartParser.this.streamEmpty)))
        </td>
      </tr><tr>
        <td>
          247
        </td>
        <td>
          20689
        </td>
        <td>
          8405
          -
          8434
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.eval
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.eval[F, Unit](rest.compile[[x]F[x], [x]F[x], Byte](fs2.this.Compiler.target[[x]F[x]](Compiler.this.Target.forConcurrent[[x]F[x]](evidence$2))).drain)
        </td>
      </tr><tr>
        <td>
          248
        </td>
        <td>
          21569
        </td>
        <td>
          8474
          -
          8485
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.multipart.MultipartParser.streamEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.streamEmpty
        </td>
      </tr><tr>
        <td>
          248
        </td>
        <td>
          15253
        </td>
        <td>
          8461
          -
          8472
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.multipart.MultipartParser.streamEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.streamEmpty
        </td>
      </tr><tr>
        <td>
          248
        </td>
        <td>
          13605
        </td>
        <td>
          8450
          -
          8487
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.pure
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.pure[Nothing, (fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing])](scala.Tuple2.apply[fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing]](MultipartParser.this.streamEmpty, MultipartParser.this.streamEmpty))
        </td>
      </tr><tr>
        <td>
          248
        </td>
        <td>
          17869
        </td>
        <td>
          8460
          -
          8486
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing]](MultipartParser.this.streamEmpty, MultipartParser.this.streamEmpty)
        </td>
      </tr><tr>
        <td>
          249
        </td>
        <td>
          17746
        </td>
        <td>
          8501
          -
          8793
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$8: (Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte], Int) = (MultipartParser.this.splitOnChunkLimited[F](values, 0, fs2.Chunk.array[Byte](scala.Predef.byteArrayOps(c1.toArray[Byte]((ClassTag.Byte: scala.reflect.ClassTag[Byte]))).++[Byte](c2.toArray[Byte]((ClassTag.Byte: scala.reflect.ClassTag[Byte])))((ClassTag.Byte: scala.reflect.ClassTag[Byte])))((ClassTag.Byte: scala.reflect.ClassTag[Byte])), fs2.Stream.empty, fs2.Stream.empty): (Int, fs2.Stream[F,Byte], fs2.Stream[F,Byte], Int) @unchecked) match {
    case (_1: Int, _2: fs2.Stream[[_]F[_],Byte], _3: fs2.Stream[[_]F[_],Byte], _4: Int): (Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte], Int)((ix @ _), (l @ _), (r @ _), (add @ _)) =&gt; scala.Tuple4.apply[Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte], Int](ix, l, r, add)
  };
  val ix: Int = x$8._1;
  val l: fs2.Stream[[_]F[_],Byte] = x$8._2;
  val r: fs2.Stream[[_]F[_],Byte] = x$8._3;
  val add: Int = x$8._4;
  go(remaining, ix, l, r, add)
}
        </td>
      </tr><tr>
        <td>
          250
        </td>
        <td>
          17183
        </td>
        <td>
          8525
          -
          8525
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple4._3
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$8._3
        </td>
      </tr><tr>
        <td>
          250
        </td>
        <td>
          15277
        </td>
        <td>
          8528
          -
          8528
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple4._4
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$8._4
        </td>
      </tr><tr>
        <td>
          250
        </td>
        <td>
          21048
        </td>
        <td>
          8522
          -
          8522
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple4._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$8._2
        </td>
      </tr><tr>
        <td>
          250
        </td>
        <td>
          14507
        </td>
        <td>
          8518
          -
          8518
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple4._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$8._1
        </td>
      </tr><tr>
        <td>
          258
        </td>
        <td>
          21431
        </td>
        <td>
          8755
          -
          8783
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.go
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          go(remaining, ix, l, r, add)
        </td>
      </tr><tr>
        <td>
          261
        </td>
        <td>
          13707
        </td>
        <td>
          8805
          -
          8816
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          c.size.==(1)
        </td>
      </tr><tr>
        <td>
          262
        </td>
        <td>
          17765
        </td>
        <td>
          8826
          -
          9066
        </td>
        <td>
          Block
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Stream.InvariantOps[[_]F[_], Byte](rest).pull.uncons.flatMap[[x]F[x], fs2.INothing, (fs2.Stream[F,Byte], fs2.Stream[F,Byte])](((x0$1: Option[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]) =&gt; x0$1 match {
  case (value: (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])): Some[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]((_1: fs2.Chunk[Byte], _2: fs2.Stream[[_]F[_],Byte]): (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])((chnk @ _), (remaining @ _))) =&gt; checkTwoNonEmpty(c, chnk, remaining)
  case scala.None =&gt; fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply(&quot;Malformed Multipart ending&quot;, MalformedMessageBodyFailure.apply$default$2))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$2))
}))
        </td>
      </tr><tr>
        <td>
          262
        </td>
        <td>
          21452
        </td>
        <td>
          8826
          -
          9066
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Stream.InvariantOps[[_]F[_], Byte](rest).pull.uncons.flatMap[[x]F[x], fs2.INothing, (fs2.Stream[F,Byte], fs2.Stream[F,Byte])](((x0$1: Option[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]) =&gt; x0$1 match {
  case (value: (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])): Some[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]((_1: fs2.Chunk[Byte], _2: fs2.Stream[[_]F[_],Byte]): (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])((chnk @ _), (remaining @ _))) =&gt; checkTwoNonEmpty(c, chnk, remaining)
  case scala.None =&gt; fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply(&quot;Malformed Multipart ending&quot;, MalformedMessageBodyFailure.apply$default$2))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$2))
}))
        </td>
      </tr><tr>
        <td>
          264
        </td>
        <td>
          20418
        </td>
        <td>
          8907
          -
          8943
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.checkTwoNonEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          checkTwoNonEmpty(c, chnk, remaining)
        </td>
      </tr><tr>
        <td>
          266
        </td>
        <td>
          18236
        </td>
        <td>
          9026
          -
          9054
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          &quot;Malformed Multipart ending&quot;
        </td>
      </tr><tr>
        <td>
          266
        </td>
        <td>
          20942
        </td>
        <td>
          8998
          -
          9055
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.MalformedMessageBodyFailure.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          MalformedMessageBodyFailure.apply(&quot;Malformed Multipart ending&quot;, MalformedMessageBodyFailure.apply$default$2)
        </td>
      </tr><tr>
        <td>
          266
        </td>
        <td>
          14530
        </td>
        <td>
          8998
          -
          8998
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.MalformedMessageBodyFailure.apply$default$2
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          MalformedMessageBodyFailure.apply$default$2
        </td>
      </tr><tr>
        <td>
          266
        </td>
        <td>
          16925
        </td>
        <td>
          8997
          -
          8997
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.RaiseThrowable.fromApplicativeError
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$2)
        </td>
      </tr><tr>
        <td>
          266
        </td>
        <td>
          13344
        </td>
        <td>
          8979
          -
          9056
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.Pull.raiseError
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply(&quot;Malformed Multipart ending&quot;, MalformedMessageBodyFailure.apply$default$2))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$2))
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          13577
        </td>
        <td>
          9084
          -
          9085
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          18257
        </td>
        <td>
          9104
          -
          9105
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          17344
        </td>
        <td>
          9078
          -
          9407
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (c.apply(0).==(MultipartParser.this.dashByte).&amp;&amp;(c.apply(1).==(MultipartParser.this.dashByte)))
  cats.syntax.`package`.all.catsSyntaxApply[[+R]fs2.Pull[F,fs2.INothing,R], Unit](fs2.Pull.eval[F, Unit](rest.compile[[x]F[x], [x]F[x], Byte](fs2.this.Compiler.target[[x]F[x]](Compiler.this.Target.forConcurrent[[x]F[x]](evidence$2))).drain))(fs2.this.Pull.monadErrorInstance[[_]F[_], fs2.INothing]).*&gt;[(fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing])](fs2.Pull.pure[Nothing, (fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing])](scala.Tuple2.apply[fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing]](MultipartParser.this.streamEmpty, MultipartParser.this.streamEmpty)))
else
  {
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$9: (Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte], Int) = (MultipartParser.this.splitOnChunkLimited[F](values, 0, c, fs2.Stream.empty, fs2.Stream.empty): (Int, fs2.Stream[F,Byte], fs2.Stream[F,Byte], Int) @unchecked) match {
      case (_1: Int, _2: fs2.Stream[[_]F[_],Byte], _3: fs2.Stream[[_]F[_],Byte], _4: Int): (Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte], Int)((ix @ _), (l @ _), (r @ _), (add @ _)) =&gt; scala.Tuple4.apply[Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte], Int](ix, l, r, add)
    };
    val ix: Int = x$9._1;
    val l: fs2.Stream[[_]F[_],Byte] = x$9._2;
    val r: fs2.Stream[[_]F[_],Byte] = x$9._3;
    val add: Int = x$9._4;
    go(rest, ix, l, r, add)
  }
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          14386
        </td>
        <td>
          9110
          -
          9118
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.multipart.MultipartParser.dashByte
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.dashByte
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          20131
        </td>
        <td>
          9090
          -
          9098
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.multipart.MultipartParser.dashByte
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.dashByte
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          16811
        </td>
        <td>
          9082
          -
          9118
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          c.apply(0).==(MultipartParser.this.dashByte).&amp;&amp;(c.apply(1).==(MultipartParser.this.dashByte))
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          20683
        </td>
        <td>
          9102
          -
          9118
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Byte.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          c.apply(1).==(MultipartParser.this.dashByte)
        </td>
      </tr><tr>
        <td>
          270
        </td>
        <td>
          13460
        </td>
        <td>
          9169
          -
          9249
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.Apply.Ops.*&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          cats.syntax.`package`.all.catsSyntaxApply[[+R]fs2.Pull[F,fs2.INothing,R], Unit](fs2.Pull.eval[F, Unit](rest.compile[[x]F[x], [x]F[x], Byte](fs2.this.Compiler.target[[x]F[x]](Compiler.this.Target.forConcurrent[[x]F[x]](evidence$2))).drain))(fs2.this.Pull.monadErrorInstance[[_]F[_], fs2.INothing]).*&gt;[(fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing])](fs2.Pull.pure[Nothing, (fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing])](scala.Tuple2.apply[fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing]](MultipartParser.this.streamEmpty, MultipartParser.this.streamEmpty)))
        </td>
      </tr><tr>
        <td>
          270
        </td>
        <td>
          21475
        </td>
        <td>
          9184
          -
          9184
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.CompilerLowPriority1.target
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Compiler.target[[x]F[x]](Compiler.this.Target.forConcurrent[[x]F[x]](evidence$2))
        </td>
      </tr><tr>
        <td>
          270
        </td>
        <td>
          13445
        </td>
        <td>
          9184
          -
          9184
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.Compiler.Target.forConcurrent
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Compiler.this.Target.forConcurrent[[x]F[x]](evidence$2)
        </td>
      </tr><tr>
        <td>
          270
        </td>
        <td>
          13597
        </td>
        <td>
          9169
          -
          9198
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.eval
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.eval[F, Unit](rest.compile[[x]F[x], [x]F[x], Byte](fs2.this.Compiler.target[[x]F[x]](Compiler.this.Target.forConcurrent[[x]F[x]](evidence$2))).drain)
        </td>
      </tr><tr>
        <td>
          270
        </td>
        <td>
          20024
        </td>
        <td>
          9178
          -
          9178
        </td>
        <td>
          TypeApply
        </td>
        <td>
          fs2.PullLowPriority.monadErrorInstance
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Pull.monadErrorInstance[[_]F[_], fs2.INothing]
        </td>
      </tr><tr>
        <td>
          270
        </td>
        <td>
          17636
        </td>
        <td>
          9179
          -
          9197
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Stream.CompileOps.drain
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          rest.compile[[x]F[x], [x]F[x], Byte](fs2.this.Compiler.target[[x]F[x]](Compiler.this.Target.forConcurrent[[x]F[x]](evidence$2))).drain
        </td>
      </tr><tr>
        <td>
          270
        </td>
        <td>
          21727
        </td>
        <td>
          9169
          -
          9249
        </td>
        <td>
          Block
        </td>
        <td>
          cats.Apply.Ops.*&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          cats.syntax.`package`.all.catsSyntaxApply[[+R]fs2.Pull[F,fs2.INothing,R], Unit](fs2.Pull.eval[F, Unit](rest.compile[[x]F[x], [x]F[x], Byte](fs2.this.Compiler.target[[x]F[x]](Compiler.this.Target.forConcurrent[[x]F[x]](evidence$2))).drain))(fs2.this.Pull.monadErrorInstance[[_]F[_], fs2.INothing]).*&gt;[(fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing])](fs2.Pull.pure[Nothing, (fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing])](scala.Tuple2.apply[fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing]](MultipartParser.this.streamEmpty, MultipartParser.this.streamEmpty)))
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          21194
        </td>
        <td>
          9222
          -
          9248
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing]](MultipartParser.this.streamEmpty, MultipartParser.this.streamEmpty)
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          14405
        </td>
        <td>
          9236
          -
          9247
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.multipart.MultipartParser.streamEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.streamEmpty
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          18507
        </td>
        <td>
          9223
          -
          9234
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.multipart.MultipartParser.streamEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.streamEmpty
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          16829
        </td>
        <td>
          9212
          -
          9249
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.pure
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.pure[Nothing, (fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing])](scala.Tuple2.apply[fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing]](MultipartParser.this.streamEmpty, MultipartParser.this.streamEmpty))
        </td>
      </tr><tr>
        <td>
          272
        </td>
        <td>
          21210
        </td>
        <td>
          9261
          -
          9407
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$9: (Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte], Int) = (MultipartParser.this.splitOnChunkLimited[F](values, 0, c, fs2.Stream.empty, fs2.Stream.empty): (Int, fs2.Stream[F,Byte], fs2.Stream[F,Byte], Int) @unchecked) match {
    case (_1: Int, _2: fs2.Stream[[_]F[_],Byte], _3: fs2.Stream[[_]F[_],Byte], _4: Int): (Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte], Int)((ix @ _), (l @ _), (r @ _), (add @ _)) =&gt; scala.Tuple4.apply[Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte], Int](ix, l, r, add)
  };
  val ix: Int = x$9._1;
  val l: fs2.Stream[[_]F[_],Byte] = x$9._2;
  val r: fs2.Stream[[_]F[_],Byte] = x$9._3;
  val add: Int = x$9._4;
  go(rest, ix, l, r, add)
}
        </td>
      </tr><tr>
        <td>
          273
        </td>
        <td>
          20407
        </td>
        <td>
          9283
          -
          9283
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple4._3
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$9._3
        </td>
      </tr><tr>
        <td>
          273
        </td>
        <td>
          16700
        </td>
        <td>
          9286
          -
          9286
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple4._4
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$9._4
        </td>
      </tr><tr>
        <td>
          273
        </td>
        <td>
          18022
        </td>
        <td>
          9276
          -
          9276
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple4._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$9._1
        </td>
      </tr><tr>
        <td>
          273
        </td>
        <td>
          14113
        </td>
        <td>
          9280
          -
          9280
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple4._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$9._2
        </td>
      </tr><tr>
        <td>
          275
        </td>
        <td>
          14662
        </td>
        <td>
          9376
          -
          9399
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.go
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          go(rest, ix, l, r, add)
        </td>
      </tr><tr>
        <td>
          286
        </td>
        <td>
          13335
        </td>
        <td>
          9594
          -
          9611
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&gt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          limitCTR.&gt;=(limit)
        </td>
      </tr><tr>
        <td>
          287
        </td>
        <td>
          20428
        </td>
        <td>
          9621
          -
          9738
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.Pull.raiseError
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply((&quot;Part header was longer than &quot;.+(limit).+(&quot;-byte limit&quot;): String), MalformedMessageBodyFailure.apply$default$2))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$2))
        </td>
      </tr><tr>
        <td>
          287
        </td>
        <td>
          14129
        </td>
        <td>
          9639
          -
          9639
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.RaiseThrowable.fromApplicativeError
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$2)
        </td>
      </tr><tr>
        <td>
          287
        </td>
        <td>
          16592
        </td>
        <td>
          9621
          -
          9738
        </td>
        <td>
          Block
        </td>
        <td>
          fs2.Pull.raiseError
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply((&quot;Part header was longer than &quot;.+(limit).+(&quot;-byte limit&quot;): String), MalformedMessageBodyFailure.apply$default$2))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$2))
        </td>
      </tr><tr>
        <td>
          288
        </td>
        <td>
          17611
        </td>
        <td>
          9651
          -
          9728
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.MalformedMessageBodyFailure.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MalformedMessageBodyFailure.apply((&quot;Part header was longer than &quot;.+(limit).+(&quot;-byte limit&quot;): String), MalformedMessageBodyFailure.apply$default$2)
        </td>
      </tr><tr>
        <td>
          288
        </td>
        <td>
          21746
        </td>
        <td>
          9651
          -
          9651
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.MalformedMessageBodyFailure.apply$default$2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MalformedMessageBodyFailure.apply$default$2
        </td>
      </tr><tr>
        <td>
          290
        </td>
        <td>
          14383
        </td>
        <td>
          9763
          -
          9776
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Array.length
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          values.length
        </td>
      </tr><tr>
        <td>
          290
        </td>
        <td>
          20857
        </td>
        <td>
          9750
          -
          10161
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (state.==(values.length))
  fs2.Pull.pure[Nothing, (fs2.Stream[F,Byte], fs2.Stream[[x]F[x],Byte])](scala.Tuple2.apply[fs2.Stream[F,Byte], fs2.Stream[[x]F[x],Byte]](lacc, racc.++[[x]F[x], Byte](s)))
else
  fs2.this.Stream.InvariantOps[[_]F[_], Byte](s).pull.uncons.flatMap[[x]F[x], fs2.INothing, (fs2.Stream[F,Byte], fs2.Stream[F,Byte])](((x0$1: Option[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]) =&gt; x0$1 match {
    case (value: (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])): Some[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]((_1: fs2.Chunk[Byte], _2: fs2.Stream[[_]F[_],Byte]): (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])((chnk @ _), (str @ _))) =&gt; {
      &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$10: (Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte], Int) = (MultipartParser.this.splitOnChunkLimited[F](values, state, chnk, lacc, racc): (Int, fs2.Stream[F,Byte], fs2.Stream[F,Byte], Int) @unchecked) match {
        case (_1: Int, _2: fs2.Stream[[_]F[_],Byte], _3: fs2.Stream[[_]F[_],Byte], _4: Int): (Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte], Int)((ix @ _), (l @ _), (r @ _), (add @ _)) =&gt; scala.Tuple4.apply[Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte], Int](ix, l, r, add)
      };
      val ix: Int = x$10._1;
      val l: fs2.Stream[[_]F[_],Byte] = x$10._2;
      val r: fs2.Stream[[_]F[_],Byte] = x$10._3;
      val add: Int = x$10._4;
      go(str, ix, l, r, limitCTR.+(add))
    }
    case scala.None =&gt; fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply(&quot;Invalid boundary - partial boundary&quot;, MalformedMessageBodyFailure.apply$default$2))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$2))
  }))
        </td>
      </tr><tr>
        <td>
          290
        </td>
        <td>
          20824
        </td>
        <td>
          9754
          -
          9776
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          state.==(values.length)
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          17363
        </td>
        <td>
          9803
          -
          9812
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          racc.++[[x]F[x], Byte](s)
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          13357
        </td>
        <td>
          9796
          -
          9813
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[fs2.Stream[F,Byte], fs2.Stream[[x]F[x],Byte]](lacc, racc.++[[x]F[x], Byte](s))
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          21616
        </td>
        <td>
          9786
          -
          9814
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.pure
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.pure[Nothing, (fs2.Stream[F,Byte], fs2.Stream[[x]F[x],Byte])](scala.Tuple2.apply[fs2.Stream[F,Byte], fs2.Stream[[x]F[x],Byte]](lacc, racc.++[[x]F[x], Byte](s)))
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          17633
        </td>
        <td>
          9786
          -
          9814
        </td>
        <td>
          Block
        </td>
        <td>
          fs2.Pull.pure
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.pure[Nothing, (fs2.Stream[F,Byte], fs2.Stream[[x]F[x],Byte])](scala.Tuple2.apply[fs2.Stream[F,Byte], fs2.Stream[[x]F[x],Byte]](lacc, racc.++[[x]F[x], Byte](s)))
        </td>
      </tr><tr>
        <td>
          293
        </td>
        <td>
          16480
        </td>
        <td>
          9834
          -
          10161
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Stream.InvariantOps[[_]F[_], Byte](s).pull.uncons.flatMap[[x]F[x], fs2.INothing, (fs2.Stream[F,Byte], fs2.Stream[F,Byte])](((x0$1: Option[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]) =&gt; x0$1 match {
  case (value: (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])): Some[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]((_1: fs2.Chunk[Byte], _2: fs2.Stream[[_]F[_],Byte]): (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])((chnk @ _), (str @ _))) =&gt; {
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$10: (Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte], Int) = (MultipartParser.this.splitOnChunkLimited[F](values, state, chnk, lacc, racc): (Int, fs2.Stream[F,Byte], fs2.Stream[F,Byte], Int) @unchecked) match {
      case (_1: Int, _2: fs2.Stream[[_]F[_],Byte], _3: fs2.Stream[[_]F[_],Byte], _4: Int): (Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte], Int)((ix @ _), (l @ _), (r @ _), (add @ _)) =&gt; scala.Tuple4.apply[Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte], Int](ix, l, r, add)
    };
    val ix: Int = x$10._1;
    val l: fs2.Stream[[_]F[_],Byte] = x$10._2;
    val r: fs2.Stream[[_]F[_],Byte] = x$10._3;
    val add: Int = x$10._4;
    go(str, ix, l, r, limitCTR.+(add))
  }
  case scala.None =&gt; fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply(&quot;Invalid boundary - partial boundary&quot;, MalformedMessageBodyFailure.apply$default$2))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$2))
}))
        </td>
      </tr><tr>
        <td>
          293
        </td>
        <td>
          14265
        </td>
        <td>
          9834
          -
          10161
        </td>
        <td>
          Block
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Stream.InvariantOps[[_]F[_], Byte](s).pull.uncons.flatMap[[x]F[x], fs2.INothing, (fs2.Stream[F,Byte], fs2.Stream[F,Byte])](((x0$1: Option[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]) =&gt; x0$1 match {
  case (value: (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])): Some[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]((_1: fs2.Chunk[Byte], _2: fs2.Stream[[_]F[_],Byte]): (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])((chnk @ _), (str @ _))) =&gt; {
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$10: (Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte], Int) = (MultipartParser.this.splitOnChunkLimited[F](values, state, chnk, lacc, racc): (Int, fs2.Stream[F,Byte], fs2.Stream[F,Byte], Int) @unchecked) match {
      case (_1: Int, _2: fs2.Stream[[_]F[_],Byte], _3: fs2.Stream[[_]F[_],Byte], _4: Int): (Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte], Int)((ix @ _), (l @ _), (r @ _), (add @ _)) =&gt; scala.Tuple4.apply[Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte], Int](ix, l, r, add)
    };
    val ix: Int = x$10._1;
    val l: fs2.Stream[[_]F[_],Byte] = x$10._2;
    val r: fs2.Stream[[_]F[_],Byte] = x$10._3;
    val add: Int = x$10._4;
    go(str, ix, l, r, limitCTR.+(add))
  }
  case scala.None =&gt; fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply(&quot;Invalid boundary - partial boundary&quot;, MalformedMessageBodyFailure.apply$default$2))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$2))
}))
        </td>
      </tr><tr>
        <td>
          295
        </td>
        <td>
          16606
        </td>
        <td>
          9918
          -
          9918
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple4._3
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$10._3
        </td>
      </tr><tr>
        <td>
          295
        </td>
        <td>
          13854
        </td>
        <td>
          9911
          -
          9911
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple4._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$10._1
        </td>
      </tr><tr>
        <td>
          295
        </td>
        <td>
          20300
        </td>
        <td>
          9915
          -
          9915
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple4._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$10._2
        </td>
      </tr><tr>
        <td>
          295
        </td>
        <td>
          14247
        </td>
        <td>
          9921
          -
          9921
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple4._4
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$10._4
        </td>
      </tr><tr>
        <td>
          296
        </td>
        <td>
          16824
        </td>
        <td>
          9996
          -
          10029
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.go
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          go(str, ix, l, r, limitCTR.+(add))
        </td>
      </tr><tr>
        <td>
          296
        </td>
        <td>
          20840
        </td>
        <td>
          10014
          -
          10028
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          limitCTR.+(add)
        </td>
      </tr><tr>
        <td>
          298
        </td>
        <td>
          19572
        </td>
        <td>
          10084
          -
          10084
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.MalformedMessageBodyFailure.apply$default$2
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          MalformedMessageBodyFailure.apply$default$2
        </td>
      </tr><tr>
        <td>
          298
        </td>
        <td>
          13745
        </td>
        <td>
          10083
          -
          10083
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.RaiseThrowable.fromApplicativeError
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$2)
        </td>
      </tr><tr>
        <td>
          298
        </td>
        <td>
          20037
        </td>
        <td>
          10065
          -
          10151
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.Pull.raiseError
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply(&quot;Invalid boundary - partial boundary&quot;, MalformedMessageBodyFailure.apply$default$2))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$2))
        </td>
      </tr><tr>
        <td>
          298
        </td>
        <td>
          17492
        </td>
        <td>
          10084
          -
          10150
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.MalformedMessageBodyFailure.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          MalformedMessageBodyFailure.apply(&quot;Invalid boundary - partial boundary&quot;, MalformedMessageBodyFailure.apply$default$2)
        </td>
      </tr><tr>
        <td>
          298
        </td>
        <td>
          13215
        </td>
        <td>
          10112
          -
          10149
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          &quot;Invalid boundary - partial boundary&quot;
        </td>
      </tr><tr>
        <td>
          301
        </td>
        <td>
          16584
        </td>
        <td>
          10167
          -
          10382
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Stream.InvariantOps[[_]F[_], Byte](stream).pull.uncons.flatMap[[x]F[x], fs2.INothing, (fs2.Stream[F,Byte], fs2.Stream[F,Byte])](((x0$1: Option[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]) =&gt; x0$1 match {
  case (value: (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])): Some[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]((_1: fs2.Chunk[Byte], _2: fs2.Stream[[_]F[_],Byte]): (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])((chunk @ _), (rest @ _))) =&gt; checkIfLast(chunk, rest)
  case scala.None =&gt; fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply(&quot;Invalid boundary - partial boundary&quot;, MalformedMessageBodyFailure.apply$default$2))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$2))
}))
        </td>
      </tr><tr>
        <td>
          303
        </td>
        <td>
          17334
        </td>
        <td>
          10238
          -
          10262
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.checkIfLast
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          checkIfLast(chunk, rest)
        </td>
      </tr><tr>
        <td>
          305
        </td>
        <td>
          17512
        </td>
        <td>
          10309
          -
          10375
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.MalformedMessageBodyFailure.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          MalformedMessageBodyFailure.apply(&quot;Invalid boundary - partial boundary&quot;, MalformedMessageBodyFailure.apply$default$2)
        </td>
      </tr><tr>
        <td>
          305
        </td>
        <td>
          12936
        </td>
        <td>
          10337
          -
          10374
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          &quot;Invalid boundary - partial boundary&quot;
        </td>
      </tr><tr>
        <td>
          305
        </td>
        <td>
          14123
        </td>
        <td>
          10308
          -
          10308
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.RaiseThrowable.fromApplicativeError
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$2)
        </td>
      </tr><tr>
        <td>
          305
        </td>
        <td>
          20561
        </td>
        <td>
          10290
          -
          10376
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.Pull.raiseError
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply(&quot;Invalid boundary - partial boundary&quot;, MalformedMessageBodyFailure.apply$default$2))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$2))
        </td>
      </tr><tr>
        <td>
          305
        </td>
        <td>
          19436
        </td>
        <td>
          10309
          -
          10309
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.MalformedMessageBodyFailure.apply$default$2
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          MalformedMessageBodyFailure.apply$default$2
        </td>
      </tr><tr>
        <td>
          314
        </td>
        <td>
          22802
        </td>
        <td>
          10677
          -
          10687
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.multipart.MultipartParser.CRLFBytesN
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.CRLFBytesN
        </td>
      </tr><tr>
        <td>
          314
        </td>
        <td>
          20701
        </td>
        <td>
          10664
          -
          11252
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.splitHalf[F](MultipartParser.this.CRLFBytesN, s).flatMap[[x]F[x], org.http4s.Headers, Unit](((x0$1: (fs2.Stream[F,Byte], fs2.Stream[F,Byte])) =&gt; x0$1 match {
  case (_1: fs2.Stream[[_]F[_],Byte], _2: fs2.Stream[[_]F[_],Byte]): (fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte])((l @ _), (r @ _)) =&gt; fs2.this.Stream.InvariantOps[[x]F[x], org.http4s.Headers](l.through[[x]F[x], String](fs2.text.utf8.decode[F]).fold[String](&quot;&quot;)(((x$11: String, x$12: String) =&gt; scala.Predef.augmentString(x$11).++(x$12))).map[org.http4s.Headers](((string: String) =&gt; {
  val ix: Int = string.indexOf(58);
  if (ix.&gt;=(0))
    headers.put(Header.this.ToRaw.rawToRaw(Header.Raw.apply(org.typelevel.ci.CIString.apply(string.substring(0, ix)), string.substring(ix.+(1)).trim())))
  else
    headers
}))).pull.echo.&gt;&gt;[[x]F[x], org.http4s.Headers, Unit](fs2.this.Stream.InvariantOps[[_]F[_], Byte](r).pull.uncons.flatMap[[x]F[x], org.http4s.Headers, Unit](((x0$2: Option[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]) =&gt; x0$2 match {
    case (value: (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])): Some[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])](_) =&gt; tailrecParse(r, headers)
    case scala.None =&gt; fs2.Pull.done
  })))
}))
        </td>
      </tr><tr>
        <td>
          315
        </td>
        <td>
          20730
        </td>
        <td>
          10735
          -
          10758
        </td>
        <td>
          TypeApply
        </td>
        <td>
          fs2.text.utf8.decode
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.text.utf8.decode[F]
        </td>
      </tr><tr>
        <td>
          316
        </td>
        <td>
          13484
        </td>
        <td>
          10780
          -
          10786
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.StringOps.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.augmentString(x$11).++(x$12)
        </td>
      </tr><tr>
        <td>
          316
        </td>
        <td>
          17358
        </td>
        <td>
          10776
          -
          10778
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          &quot;&quot;
        </td>
      </tr><tr>
        <td>
          317
        </td>
        <td>
          17787
        </td>
        <td>
          10725
          -
          11067
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          l.through[[x]F[x], String](fs2.text.utf8.decode[F]).fold[String](&quot;&quot;)(((x$11: String, x$12: String) =&gt; scala.Predef.augmentString(x$11).++(x$12))).map[org.http4s.Headers](((string: String) =&gt; {
  val ix: Int = string.indexOf(58);
  if (ix.&gt;=(0))
    headers.put(Header.this.ToRaw.rawToRaw(Header.Raw.apply(org.typelevel.ci.CIString.apply(string.substring(0, ix)), string.substring(ix.+(1)).trim())))
  else
    headers
}))
        </td>
      </tr><tr>
        <td>
          318
        </td>
        <td>
          19820
        </td>
        <td>
          10836
          -
          10855
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.String.indexOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          string.indexOf(58)
        </td>
      </tr><tr>
        <td>
          319
        </td>
        <td>
          17537
        </td>
        <td>
          10872
          -
          10879
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&gt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ix.&gt;=(0)
        </td>
      </tr><tr>
        <td>
          320
        </td>
        <td>
          13205
        </td>
        <td>
          10895
          -
          11016
        </td>
        <td>
          Block
        </td>
        <td>
          org.http4s.Headers.put
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          headers.put(Header.this.ToRaw.rawToRaw(Header.Raw.apply(org.typelevel.ci.CIString.apply(string.substring(0, ix)), string.substring(ix.+(1)).trim())))
        </td>
      </tr><tr>
        <td>
          320
        </td>
        <td>
          17221
        </td>
        <td>
          10895
          -
          11016
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.Headers.put
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          headers.put(Header.this.ToRaw.rawToRaw(Header.Raw.apply(org.typelevel.ci.CIString.apply(string.substring(0, ix)), string.substring(ix.+(1)).trim())))
        </td>
      </tr><tr>
        <td>
          321
        </td>
        <td>
          13991
        </td>
        <td>
          10944
          -
          10967
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.String.substring
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          string.substring(0, ix)
        </td>
      </tr><tr>
        <td>
          321
        </td>
        <td>
          20579
        </td>
        <td>
          10935
          -
          10968
        </td>
        <td>
          Apply
        </td>
        <td>
          org.typelevel.ci.CIString.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.typelevel.ci.CIString.apply(string.substring(0, ix))
        </td>
      </tr><tr>
        <td>
          321
        </td>
        <td>
          23022
        </td>
        <td>
          10924
          -
          11000
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.Header.Raw.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Header.Raw.apply(org.typelevel.ci.CIString.apply(string.substring(0, ix)), string.substring(ix.+(1)).trim())
        </td>
      </tr><tr>
        <td>
          321
        </td>
        <td>
          21105
        </td>
        <td>
          10924
          -
          11000
        </td>
        <td>
          ApplyImplicitView
        </td>
        <td>
          org.http4s.Header.ToRaw.rawToRaw
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Header.this.ToRaw.rawToRaw(Header.Raw.apply(org.typelevel.ci.CIString.apply(string.substring(0, ix)), string.substring(ix.+(1)).trim()))
        </td>
      </tr><tr>
        <td>
          321
        </td>
        <td>
          16454
        </td>
        <td>
          10970
          -
          10999
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.String.trim
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          string.substring(ix.+(1)).trim()
        </td>
      </tr><tr>
        <td>
          324
        </td>
        <td>
          19837
        </td>
        <td>
          11048
          -
          11055
        </td>
        <td>
          Ident
        </td>
        <td>
          org.http4s.multipart.MultipartParser.headers
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          headers
        </td>
      </tr><tr>
        <td>
          327
        </td>
        <td>
          23032
        </td>
        <td>
          10725
          -
          11244
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.&gt;&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Stream.InvariantOps[[x]F[x], org.http4s.Headers](l.through[[x]F[x], String](fs2.text.utf8.decode[F]).fold[String](&quot;&quot;)(((x$11: String, x$12: String) =&gt; scala.Predef.augmentString(x$11).++(x$12))).map[org.http4s.Headers](((string: String) =&gt; {
  val ix: Int = string.indexOf(58);
  if (ix.&gt;=(0))
    headers.put(Header.this.ToRaw.rawToRaw(Header.Raw.apply(org.typelevel.ci.CIString.apply(string.substring(0, ix)), string.substring(ix.+(1)).trim())))
  else
    headers
}))).pull.echo.&gt;&gt;[[x]F[x], org.http4s.Headers, Unit](fs2.this.Stream.InvariantOps[[_]F[_], Byte](r).pull.uncons.flatMap[[x]F[x], org.http4s.Headers, Unit](((x0$2: Option[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]) =&gt; x0$2 match {
  case (value: (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])): Some[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])](_) =&gt; tailrecParse(r, headers)
  case scala.None =&gt; fs2.Pull.done
})))
        </td>
      </tr><tr>
        <td>
          327
        </td>
        <td>
          16470
        </td>
        <td>
          11103
          -
          11244
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Stream.InvariantOps[[_]F[_], Byte](r).pull.uncons.flatMap[[x]F[x], org.http4s.Headers, Unit](((x0$2: Option[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]) =&gt; x0$2 match {
  case (value: (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])): Some[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])](_) =&gt; tailrecParse(r, headers)
  case scala.None =&gt; fs2.Pull.done
}))
        </td>
      </tr><tr>
        <td>
          329
        </td>
        <td>
          14010
        </td>
        <td>
          11165
          -
          11189
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.tailrecParse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          tailrecParse(r, headers)
        </td>
      </tr><tr>
        <td>
          331
        </td>
        <td>
          20453
        </td>
        <td>
          11225
          -
          11234
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Pull.done
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.done
        </td>
      </tr><tr>
        <td>
          335
        </td>
        <td>
          20192
        </td>
        <td>
          11258
          -
          11318
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.Stream.CompileOps.foldMonoid
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Pull.StreamPullOps[[_]F[_], org.http4s.Headers](tailrecParse(strim, Headers.empty)).stream.compile[[x]F[x], [x]F[x], org.http4s.Headers](fs2.this.Compiler.target[[x]F[x]](Compiler.this.Target.forConcurrent[[x]F[x]](evidence$3))).foldMonoid(http4s.this.Headers.headersMonoid)
        </td>
      </tr><tr>
        <td>
          335
        </td>
        <td>
          13080
        </td>
        <td>
          11258
          -
          11292
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.tailrecParse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          tailrecParse(strim, Headers.empty)
        </td>
      </tr><tr>
        <td>
          335
        </td>
        <td>
          13618
        </td>
        <td>
          11308
          -
          11308
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.Headers.headersMonoid
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          http4s.this.Headers.headersMonoid
        </td>
      </tr><tr>
        <td>
          335
        </td>
        <td>
          19727
        </td>
        <td>
          11300
          -
          11300
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.Compiler.Target.forConcurrent
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Compiler.this.Target.forConcurrent[[x]F[x]](evidence$3)
        </td>
      </tr><tr>
        <td>
          335
        </td>
        <td>
          15710
        </td>
        <td>
          11300
          -
          11300
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.CompilerLowPriority1.target
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Compiler.target[[x]F[x]](Compiler.this.Target.forConcurrent[[x]F[x]](evidence$3))
        </td>
      </tr><tr>
        <td>
          335
        </td>
        <td>
          17241
        </td>
        <td>
          11278
          -
          11291
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.Headers.empty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Headers.empty
        </td>
      </tr><tr>
        <td>
          351
        </td>
        <td>
          22928
        </td>
        <td>
          11809
          -
          11831
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          state.==(values.length)
        </td>
      </tr><tr>
        <td>
          351
        </td>
        <td>
          16495
        </td>
        <td>
          11818
          -
          11831
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Array.length
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          values.length
        </td>
      </tr><tr>
        <td>
          352
        </td>
        <td>
          13095
        </td>
        <td>
          11841
          -
          11869
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.pure
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.pure[Nothing, (fs2.Stream[F,Byte], fs2.Stream[[x]F[x],Byte])](scala.Tuple2.apply[fs2.Stream[F,Byte], fs2.Stream[[x]F[x],Byte]](lacc, racc.++[[x]F[x], Byte](s)))
        </td>
      </tr><tr>
        <td>
          352
        </td>
        <td>
          20727
        </td>
        <td>
          11858
          -
          11867
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          racc.++[[x]F[x], Byte](s)
        </td>
      </tr><tr>
        <td>
          352
        </td>
        <td>
          16845
        </td>
        <td>
          11851
          -
          11868
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[fs2.Stream[F,Byte], fs2.Stream[[x]F[x],Byte]](lacc, racc.++[[x]F[x], Byte](s))
        </td>
      </tr><tr>
        <td>
          352
        </td>
        <td>
          19743
        </td>
        <td>
          11841
          -
          11869
        </td>
        <td>
          Block
        </td>
        <td>
          fs2.Pull.pure
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.pure[Nothing, (fs2.Stream[F,Byte], fs2.Stream[[x]F[x],Byte])](scala.Tuple2.apply[fs2.Stream[F,Byte], fs2.Stream[[x]F[x],Byte]](lacc, racc.++[[x]F[x], Byte](s)))
        </td>
      </tr><tr>
        <td>
          354
        </td>
        <td>
          19614
        </td>
        <td>
          11889
          -
          12198
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Stream.InvariantOps[[_]F[_], Byte](s).pull.uncons.flatMap[[x]F[x], fs2.INothing, (fs2.Stream[F,Byte], fs2.Stream[F,Byte])](((x0$1: Option[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]) =&gt; x0$1 match {
  case (value: (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])): Some[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]((_1: fs2.Chunk[Byte], _2: fs2.Stream[[_]F[_],Byte]): (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])((chnk @ _), (str @ _))) =&gt; {
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$13: (Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte]) = (MultipartParser.this.splitOnChunk[F](values, state, chnk, lacc, racc): (Int, fs2.Stream[F,Byte], fs2.Stream[F,Byte]) @unchecked) match {
      case (_1: Int, _2: fs2.Stream[[_]F[_],Byte], _3: fs2.Stream[[_]F[_],Byte]): (Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte])((ix @ _), (l @ _), (r @ _)) =&gt; scala.Tuple3.apply[Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte]](ix, l, r)
    };
    val ix: Int = x$13._1;
    val l: fs2.Stream[[_]F[_],Byte] = x$13._2;
    val r: fs2.Stream[[_]F[_],Byte] = x$13._3;
    go(str, ix, l, r)
  }
  case scala.None =&gt; fs2.Pull.pure[Nothing, (fs2.Stream[[x]F[x],Byte], fs2.Stream[fs2.Pure,fs2.INothing])](scala.Tuple2.apply[fs2.Stream[[x]F[x],Byte], fs2.Stream[fs2.Pure,fs2.INothing]](lacc.++[[x]F[x], Byte](racc), MultipartParser.this.streamEmpty))
}))
        </td>
      </tr><tr>
        <td>
          354
        </td>
        <td>
          15599
        </td>
        <td>
          11889
          -
          12198
        </td>
        <td>
          Block
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Stream.InvariantOps[[_]F[_], Byte](s).pull.uncons.flatMap[[x]F[x], fs2.INothing, (fs2.Stream[F,Byte], fs2.Stream[F,Byte])](((x0$1: Option[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]) =&gt; x0$1 match {
  case (value: (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])): Some[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]((_1: fs2.Chunk[Byte], _2: fs2.Stream[[_]F[_],Byte]): (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])((chnk @ _), (str @ _))) =&gt; {
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$13: (Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte]) = (MultipartParser.this.splitOnChunk[F](values, state, chnk, lacc, racc): (Int, fs2.Stream[F,Byte], fs2.Stream[F,Byte]) @unchecked) match {
      case (_1: Int, _2: fs2.Stream[[_]F[_],Byte], _3: fs2.Stream[[_]F[_],Byte]): (Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte])((ix @ _), (l @ _), (r @ _)) =&gt; scala.Tuple3.apply[Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte]](ix, l, r)
    };
    val ix: Int = x$13._1;
    val l: fs2.Stream[[_]F[_],Byte] = x$13._2;
    val r: fs2.Stream[[_]F[_],Byte] = x$13._3;
    go(str, ix, l, r)
  }
  case scala.None =&gt; fs2.Pull.pure[Nothing, (fs2.Stream[[x]F[x],Byte], fs2.Stream[fs2.Pure,fs2.INothing])](scala.Tuple2.apply[fs2.Stream[[x]F[x],Byte], fs2.Stream[fs2.Pure,fs2.INothing]](lacc.++[[x]F[x], Byte](racc), MultipartParser.this.streamEmpty))
}))
        </td>
      </tr><tr>
        <td>
          356
        </td>
        <td>
          13638
        </td>
        <td>
          11970
          -
          11970
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple3._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$13._2
        </td>
      </tr><tr>
        <td>
          356
        </td>
        <td>
          15579
        </td>
        <td>
          11966
          -
          11966
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple3._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$13._1
        </td>
      </tr><tr>
        <td>
          356
        </td>
        <td>
          20576
        </td>
        <td>
          11973
          -
          11973
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple3._3
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$13._3
        </td>
      </tr><tr>
        <td>
          357
        </td>
        <td>
          16360
        </td>
        <td>
          12039
          -
          12056
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.go
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          go(str, ix, l, r)
        </td>
      </tr><tr>
        <td>
          360
        </td>
        <td>
          13496
        </td>
        <td>
          12150
          -
          12188
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.pure
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.pure[Nothing, (fs2.Stream[[x]F[x],Byte], fs2.Stream[fs2.Pure,fs2.INothing])](scala.Tuple2.apply[fs2.Stream[[x]F[x],Byte], fs2.Stream[fs2.Pure,fs2.INothing]](lacc.++[[x]F[x], Byte](racc), MultipartParser.this.streamEmpty))
        </td>
      </tr><tr>
        <td>
          360
        </td>
        <td>
          22660
        </td>
        <td>
          12161
          -
          12173
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          lacc.++[[x]F[x], Byte](racc)
        </td>
      </tr><tr>
        <td>
          360
        </td>
        <td>
          16864
        </td>
        <td>
          12160
          -
          12187
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[fs2.Stream[[x]F[x],Byte], fs2.Stream[fs2.Pure,fs2.INothing]](lacc.++[[x]F[x], Byte](racc), MultipartParser.this.streamEmpty)
        </td>
      </tr><tr>
        <td>
          360
        </td>
        <td>
          21227
        </td>
        <td>
          12175
          -
          12186
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.multipart.MultipartParser.streamEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.streamEmpty
        </td>
      </tr><tr>
        <td>
          363
        </td>
        <td>
          16106
        </td>
        <td>
          12204
          -
          12451
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Stream.InvariantOps[[_]F[_], Byte](stream).pull.uncons.flatMap[[x]F[x], fs2.INothing, (fs2.Stream[F,Byte], fs2.Stream[F,Byte])](((x0$1: Option[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]) =&gt; x0$1 match {
  case (value: (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])): Some[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]((_1: fs2.Chunk[Byte], _2: fs2.Stream[[_]F[_],Byte]): (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])((chunk @ _), (rest @ _))) =&gt; {
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$14: (Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte]) = (MultipartParser.this.splitOnChunk[F](values, 0, chunk, fs2.Stream.empty, fs2.Stream.empty): (Int, fs2.Stream[F,Byte], fs2.Stream[F,Byte]) @unchecked) match {
      case (_1: Int, _2: fs2.Stream[[_]F[_],Byte], _3: fs2.Stream[[_]F[_],Byte]): (Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte])((ix @ _), (l @ _), (r @ _)) =&gt; scala.Tuple3.apply[Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte]](ix, l, r)
    };
    val ix: Int = x$14._1;
    val l: fs2.Stream[[_]F[_],Byte] = x$14._2;
    val r: fs2.Stream[[_]F[_],Byte] = x$14._3;
    go(rest, ix, l, r)
  }
  case scala.None =&gt; fs2.Pull.pure[Nothing, (fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing])](scala.Tuple2.apply[fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing]](MultipartParser.this.streamEmpty, MultipartParser.this.streamEmpty))
}))
        </td>
      </tr><tr>
        <td>
          365
        </td>
        <td>
          16735
        </td>
        <td>
          12287
          -
          12287
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple3._3
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$14._3
        </td>
      </tr><tr>
        <td>
          365
        </td>
        <td>
          14148
        </td>
        <td>
          12280
          -
          12280
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple3._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$14._1
        </td>
      </tr><tr>
        <td>
          365
        </td>
        <td>
          20447
        </td>
        <td>
          12284
          -
          12284
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple3._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$14._2
        </td>
      </tr><tr>
        <td>
          366
        </td>
        <td>
          23174
        </td>
        <td>
          12362
          -
          12380
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.go
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          go(rest, ix, l, r)
        </td>
      </tr><tr>
        <td>
          368
        </td>
        <td>
          18830
        </td>
        <td>
          12419
          -
          12430
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.multipart.MultipartParser.streamEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          MultipartParser.this.streamEmpty
        </td>
      </tr><tr>
        <td>
          368
        </td>
        <td>
          17236
        </td>
        <td>
          12432
          -
          12443
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.multipart.MultipartParser.streamEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          MultipartParser.this.streamEmpty
        </td>
      </tr><tr>
        <td>
          368
        </td>
        <td>
          13374
        </td>
        <td>
          12418
          -
          12444
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.Tuple2.apply[fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing]](MultipartParser.this.streamEmpty, MultipartParser.this.streamEmpty)
        </td>
      </tr><tr>
        <td>
          368
        </td>
        <td>
          19720
        </td>
        <td>
          12408
          -
          12445
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.pure
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.Pull.pure[Nothing, (fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing])](scala.Tuple2.apply[fs2.Stream[fs2.Pure,fs2.INothing], fs2.Stream[fs2.Pure,fs2.INothing]](MultipartParser.this.streamEmpty, MultipartParser.this.streamEmpty))
        </td>
      </tr><tr>
        <td>
          394
        </td>
        <td>
          19591
        </td>
        <td>
          13207
          -
          13416
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple4.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple4.apply[Int, fs2.Stream[[x]F[x],Byte], fs2.Stream[[x]fs2.Pure[x],Byte], Int](sti, acc.++[[x]F[x], Byte](carry).++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.take(i.-(sti)))), fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.drop(i)), state.+(i).-(sti))
        </td>
      </tr><tr>
        <td>
          394
        </td>
        <td>
          15850
        </td>
        <td>
          13207
          -
          13416
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Tuple4.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple4.apply[Int, fs2.Stream[[x]F[x],Byte], fs2.Stream[[x]fs2.Pure[x],Byte], Int](sti, acc.++[[x]F[x], Byte](carry).++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.take(i.-(sti)))), fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.drop(i)), state.+(i).-(sti))
        </td>
      </tr><tr>
        <td>
          397
        </td>
        <td>
          20466
        </td>
        <td>
          13301
          -
          13316
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Chunk.take
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          c.take(i.-(sti))
        </td>
      </tr><tr>
        <td>
          397
        </td>
        <td>
          16623
        </td>
        <td>
          13288
          -
          13317
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.chunk
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.take(i.-(sti)))
        </td>
      </tr><tr>
        <td>
          397
        </td>
        <td>
          14170
        </td>
        <td>
          13308
          -
          13315
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          i.-(sti)
        </td>
      </tr><tr>
        <td>
          397
        </td>
        <td>
          22920
        </td>
        <td>
          13272
          -
          13317
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          acc.++[[x]F[x], Byte](carry).++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.take(i.-(sti))))
        </td>
      </tr><tr>
        <td>
          399
        </td>
        <td>
          19333
        </td>
        <td>
          13372
          -
          13381
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Chunk.drop
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          c.drop(i)
        </td>
      </tr><tr>
        <td>
          399
        </td>
        <td>
          17107
        </td>
        <td>
          13359
          -
          13382
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.chunk
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.drop(i))
        </td>
      </tr><tr>
        <td>
          400
        </td>
        <td>
          13392
        </td>
        <td>
          13392
          -
          13407
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          state.+(i).-(sti)
        </td>
      </tr><tr>
        <td>
          403
        </td>
        <td>
          19055
        </td>
        <td>
          13432
          -
          13601
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Tuple4.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple4.apply[Int, fs2.Stream[F,Byte], fs2.Stream[[x]fs2.Pure[x],Byte], Int](sti, acc, fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.drop(i)), 0)
        </td>
      </tr><tr>
        <td>
          403
        </td>
        <td>
          22801
        </td>
        <td>
          13432
          -
          13601
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple4.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple4.apply[Int, fs2.Stream[F,Byte], fs2.Stream[[x]fs2.Pure[x],Byte], Int](sti, acc, fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.drop(i)), 0)
        </td>
      </tr><tr>
        <td>
          406
        </td>
        <td>
          20331
        </td>
        <td>
          13523
          -
          13546
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.chunk
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c.drop(i))
        </td>
      </tr><tr>
        <td>
          406
        </td>
        <td>
          22388
        </td>
        <td>
          13536
          -
          13545
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Chunk.drop
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          c.drop(i)
        </td>
      </tr><tr>
        <td>
          407
        </td>
        <td>
          16354
        </td>
        <td>
          13591
          -
          13592
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          433
        </td>
        <td>
          17127
        </td>
        <td>
          14437
          -
          14450
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          i.-(currState)
        </td>
      </tr><tr>
        <td>
          434
        </td>
        <td>
          18822
        </td>
        <td>
          14474
          -
          14680
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$15: (fs2.Chunk[Byte], fs2.Chunk[Byte]) = (c.splitAt(ixx): (fs2.Chunk[Byte], fs2.Chunk[Byte]) @unchecked) match {
    case (_1: fs2.Chunk[Byte], _2: fs2.Chunk[Byte]): (fs2.Chunk[Byte], fs2.Chunk[Byte])((lchunk @ _), (rchunk @ _)) =&gt; scala.Tuple2.apply[fs2.Chunk[Byte], fs2.Chunk[Byte]](lchunk, rchunk)
  };
  val lchunk: fs2.Chunk[Byte] = x$15._1;
  val rchunk: fs2.Chunk[Byte] = x$15._2;
  scala.Tuple4.apply[Int, fs2.Stream[[x]F[x],Byte], fs2.Stream[[x]fs2.Pure[x],Byte], Int](currState, acc.++[[x]F[x], Byte](carry).++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](lchunk)), fs2.Stream.chunk[[x]fs2.Pure[x], Byte](rchunk), state.+(ixx))
}
        </td>
      </tr><tr>
        <td>
          435
        </td>
        <td>
          13253
        </td>
        <td>
          14487
          -
          14487
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$15._1
        </td>
      </tr><tr>
        <td>
          435
        </td>
        <td>
          19605
        </td>
        <td>
          14495
          -
          14495
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$15._2
        </td>
      </tr><tr>
        <td>
          436
        </td>
        <td>
          22821
        </td>
        <td>
          14526
          -
          14674
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple4.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple4.apply[Int, fs2.Stream[[x]F[x],Byte], fs2.Stream[[x]fs2.Pure[x],Byte], Int](currState, acc.++[[x]F[x], Byte](carry).++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](lchunk)), fs2.Stream.chunk[[x]fs2.Pure[x], Byte](rchunk), state.+(ixx))
        </td>
      </tr><tr>
        <td>
          438
        </td>
        <td>
          21991
        </td>
        <td>
          14555
          -
          14591
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          acc.++[[x]F[x], Byte](carry).++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](lchunk))
        </td>
      </tr><tr>
        <td>
          438
        </td>
        <td>
          15863
        </td>
        <td>
          14571
          -
          14591
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.chunk
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.chunk[[x]fs2.Pure[x], Byte](lchunk)
        </td>
      </tr><tr>
        <td>
          439
        </td>
        <td>
          20349
        </td>
        <td>
          14624
          -
          14644
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.chunk
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.chunk[[x]fs2.Pure[x], Byte](rchunk)
        </td>
      </tr><tr>
        <td>
          440
        </td>
        <td>
          16232
        </td>
        <td>
          14654
          -
          14665
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          state.+(ixx)
        </td>
      </tr><tr>
        <td>
          444
        </td>
        <td>
          12994
        </td>
        <td>
          14747
          -
          14771
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          carry.++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c))
        </td>
      </tr><tr>
        <td>
          444
        </td>
        <td>
          22007
        </td>
        <td>
          14730
          -
          14775
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Tuple4.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple4.apply[Int, fs2.Stream[F,Byte], fs2.Stream[[x]F[x],Byte], Int](currState, acc, carry.++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c)), 0)
        </td>
      </tr><tr>
        <td>
          444
        </td>
        <td>
          17377
        </td>
        <td>
          14756
          -
          14771
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.chunk
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c)
        </td>
      </tr><tr>
        <td>
          444
        </td>
        <td>
          15756
        </td>
        <td>
          14730
          -
          14775
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple4.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple4.apply[Int, fs2.Stream[F,Byte], fs2.Stream[[x]F[x],Byte], Int](currState, acc, carry.++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c)), 0)
        </td>
      </tr><tr>
        <td>
          444
        </td>
        <td>
          19475
        </td>
        <td>
          14773
          -
          14774
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          454
        </td>
        <td>
          20596
        </td>
        <td>
          15021
          -
          15022
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          456
        </td>
        <td>
          16245
        </td>
        <td>
          15063
          -
          15076
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Array.length
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          values.length
        </td>
      </tr><tr>
        <td>
          457
        </td>
        <td>
          22548
        </td>
        <td>
          15119
          -
          15119
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.while$3
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          while$3()
        </td>
      </tr><tr>
        <td>
          457
        </td>
        <td>
          19324
        </td>
        <td>
          15107
          -
          15117
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          i.&lt;(c.size)
        </td>
      </tr><tr>
        <td>
          457
        </td>
        <td>
          20206
        </td>
        <td>
          15119
          -
          15288
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  {
    if (c.apply(i).==(values.apply(currState)))
      currState = currState.+(1)
    else
      if (c.apply(i).==(values.apply(0)))
        currState = 1
      else
        currState = 0;
    i = i.+(1)
  };
  while$3()
}
        </td>
      </tr><tr>
        <td>
          457
        </td>
        <td>
          16515
        </td>
        <td>
          15081
          -
          15081
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          457
        </td>
        <td>
          22816
        </td>
        <td>
          15081
          -
          15081
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          457
        </td>
        <td>
          22839
        </td>
        <td>
          15111
          -
          15117
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Chunk.size
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          c.size
        </td>
      </tr><tr>
        <td>
          457
        </td>
        <td>
          14917
        </td>
        <td>
          15088
          -
          15117
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          currState.&lt;(len).&amp;&amp;(i.&lt;(c.size))
        </td>
      </tr><tr>
        <td>
          458
        </td>
        <td>
          19490
        </td>
        <td>
          15131
          -
          15156
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Byte.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          c.apply(i).==(values.apply(currState))
        </td>
      </tr><tr>
        <td>
          458
        </td>
        <td>
          13224
        </td>
        <td>
          15139
          -
          15156
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Array.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          values.apply(currState)
        </td>
      </tr><tr>
        <td>
          459
        </td>
        <td>
          16117
        </td>
        <td>
          15166
          -
          15180
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          currState.+(1)
        </td>
      </tr><tr>
        <td>
          459
        </td>
        <td>
          22525
        </td>
        <td>
          15166
          -
          15180
        </td>
        <td>
          Assign
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          currState = currState.+(1)
        </td>
      </tr><tr>
        <td>
          460
        </td>
        <td>
          19871
        </td>
        <td>
          15192
          -
          15269
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (c.apply(i).==(values.apply(0)))
  currState = 1
else
  currState = 0
        </td>
      </tr><tr>
        <td>
          460
        </td>
        <td>
          20618
        </td>
        <td>
          15204
          -
          15213
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Array.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          values.apply(0)
        </td>
      </tr><tr>
        <td>
          460
        </td>
        <td>
          16643
        </td>
        <td>
          15196
          -
          15213
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Byte.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          c.apply(i).==(values.apply(0))
        </td>
      </tr><tr>
        <td>
          461
        </td>
        <td>
          19344
        </td>
        <td>
          15223
          -
          15236
        </td>
        <td>
          Assign
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          currState = 1
        </td>
      </tr><tr>
        <td>
          461
        </td>
        <td>
          22705
        </td>
        <td>
          15235
          -
          15236
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          1
        </td>
      </tr><tr>
        <td>
          463
        </td>
        <td>
          13248
        </td>
        <td>
          15256
          -
          15269
        </td>
        <td>
          Assign
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          currState = 0
        </td>
      </tr><tr>
        <td>
          463
        </td>
        <td>
          15462
        </td>
        <td>
          15268
          -
          15269
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          464
        </td>
        <td>
          15997
        </td>
        <td>
          15276
          -
          15282
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          i.+(1)
        </td>
      </tr><tr>
        <td>
          471
        </td>
        <td>
          19219
        </td>
        <td>
          15464
          -
          15489
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          i.+(state).-(currState).&gt;(0)
        </td>
      </tr><tr>
        <td>
          473
        </td>
        <td>
          15479
        </td>
        <td>
          15499
          -
          15513
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          currState.==(0)
        </td>
      </tr><tr>
        <td>
          474
        </td>
        <td>
          15750
        </td>
        <td>
          15525
          -
          15556
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          acc.++[[x]F[x], Byte](carry).++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c))
        </td>
      </tr><tr>
        <td>
          474
        </td>
        <td>
          19763
        </td>
        <td>
          15541
          -
          15556
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.chunk
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c)
        </td>
      </tr><tr>
        <td>
          474
        </td>
        <td>
          13273
        </td>
        <td>
          15522
          -
          15523
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          474
        </td>
        <td>
          22409
        </td>
        <td>
          15558
          -
          15570
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Stream.empty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.empty
        </td>
      </tr><tr>
        <td>
          474
        </td>
        <td>
          18425
        </td>
        <td>
          15521
          -
          15574
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple4.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple4.apply[Int, fs2.Stream[[x]F[x],Byte], fs2.Stream[fs2.Pure,fs2.INothing], Int](0, acc.++[[x]F[x], Byte](carry).++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c)), fs2.Stream.empty, i)
        </td>
      </tr><tr>
        <td>
          474
        </td>
        <td>
          16535
        </td>
        <td>
          15521
          -
          15574
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Tuple4.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple4.apply[Int, fs2.Stream[[x]F[x],Byte], fs2.Stream[fs2.Pure,fs2.INothing], Int](0, acc.++[[x]F[x], Byte](carry).++[[x]F[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](c)), fs2.Stream.empty, i)
        </td>
      </tr><tr>
        <td>
          475
        </td>
        <td>
          15622
        </td>
        <td>
          15584
          -
          15769
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (currState.==(len))
  MultipartParser.this.splitCompleteLimited[[_]F[_]](state, middleChunked, currState, i, acc, carry, c)
else
  MultipartParser.this.splitPartialLimited[[_]F[_]](state, middleChunked, currState, i, acc, carry, c)
        </td>
      </tr><tr>
        <td>
          475
        </td>
        <td>
          22678
        </td>
        <td>
          15588
          -
          15604
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          currState.==(len)
        </td>
      </tr><tr>
        <td>
          476
        </td>
        <td>
          15051
        </td>
        <td>
          15612
          -
          15683
        </td>
        <td>
          Block
        </td>
        <td>
          org.http4s.multipart.MultipartParser.splitCompleteLimited
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.splitCompleteLimited[[_]F[_]](state, middleChunked, currState, i, acc, carry, c)
        </td>
      </tr><tr>
        <td>
          476
        </td>
        <td>
          18958
        </td>
        <td>
          15612
          -
          15683
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.splitCompleteLimited
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.splitCompleteLimited[[_]F[_]](state, middleChunked, currState, i, acc, carry, c)
        </td>
      </tr><tr>
        <td>
          478
        </td>
        <td>
          19486
        </td>
        <td>
          15699
          -
          15769
        </td>
        <td>
          Block
        </td>
        <td>
          org.http4s.multipart.MultipartParser.splitPartialLimited
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.splitPartialLimited[[_]F[_]](state, middleChunked, currState, i, acc, carry, c)
        </td>
      </tr><tr>
        <td>
          478
        </td>
        <td>
          13130
        </td>
        <td>
          15699
          -
          15769
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.splitPartialLimited
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.splitPartialLimited[[_]F[_]](state, middleChunked, currState, i, acc, carry, c)
        </td>
      </tr><tr>
        <td>
          497
        </td>
        <td>
          22129
        </td>
        <td>
          16357
          -
          16441
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          org.http4s.multipart.MultipartParser.parseToPartsStreamedFile
        </td>
        <td>
          org.http4s.multipart.multipartparsersuite
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.parseToPartsStreamedFile[[_]F[_]](boundary, limit, maxSizeBeforeWrite, maxParts, failOnLimit)(evidence$4, evidence$5)
        </td>
      </tr><tr>
        <td>
          498
        </td>
        <td>
          16394
        </td>
        <td>
          16476
          -
          16482
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.SeqOps.:+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$16.:+[org.http4s.multipart.Part[F]](x$17)
        </td>
      </tr><tr>
        <td>
          498
        </td>
        <td>
          18447
        </td>
        <td>
          16453
          -
          16474
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.Vector.empty
        </td>
        <td>
          org.http4s.multipart.multipartparsersuite
        </td>
        <td style="background: #AEF1AE">
          scala.`package`.Vector.empty[org.http4s.multipart.Part[F]]
        </td>
      </tr><tr>
        <td>
          499
        </td>
        <td>
          18846
        </td>
        <td>
          16339
          -
          16518
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.map
        </td>
        <td>
          org.http4s.multipart.multipartparsersuite
        </td>
        <td style="background: #AEF1AE">
          st.through[[x]F[x], org.http4s.multipart.Part[[_]F[_]]](MultipartParser.this.parseToPartsStreamedFile[[_]F[_]](boundary, limit, maxSizeBeforeWrite, maxParts, failOnLimit)(evidence$4, evidence$5)).fold[scala.collection.immutable.Vector[org.http4s.multipart.Part[F]]](scala.`package`.Vector.empty[org.http4s.multipart.Part[F]])(((x$16: scala.collection.immutable.Vector[org.http4s.multipart.Part[F]], x$17: org.http4s.multipart.Part[[_]F[_]]) =&gt; x$16.:+[org.http4s.multipart.Part[F]](x$17))).map[org.http4s.multipart.Multipart[[_]F[_]]](((x$18: scala.collection.immutable.Vector[org.http4s.multipart.Part[F]]) =&gt; Multipart.apply[[_]F[_]](x$18, boundary)))
        </td>
      </tr><tr>
        <td>
          499
        </td>
        <td>
          22698
        </td>
        <td>
          16495
          -
          16517
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.Multipart.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Multipart.apply[[_]F[_]](x$18, boundary)
        </td>
      </tr><tr>
        <td>
          526
        </td>
        <td>
          15451
        </td>
        <td>
          16884
          -
          17455
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Function1.apply
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.loop[F, org.http4s.multipart.Part[F], fs2.Stream[F,org.http4s.multipart.MultipartParser.Event]](((x$19: fs2.Stream[F,org.http4s.multipart.MultipartParser.Event]) =&gt; fs2.this.Stream.InvariantOps[[_]F[_], org.http4s.multipart.MultipartParser.Event](x$19).pull.uncons1.flatMap[[x]F[x], org.http4s.multipart.Part[F], Option[fs2.Stream[F,org.http4s.multipart.MultipartParser.Event]]](((x$20: Option[(org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])]) =&gt; cats.syntax.`package`.all.toTraverseOps[Option, (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])](x$20)(cats.this.UnorderedFoldable.catsTraverseForOption).traverse[[+R]fs2.Pull[[_]F[_],org.http4s.multipart.Part[F],R], fs2.Stream[F,org.http4s.multipart.MultipartParser.Event]](((x0$1: (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])) =&gt; x0$1 match {
  case (_1: org.http4s.multipart.MultipartParser.Event, _2: fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]): (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])((value: org.http4s.Headers): org.http4s.multipart.MultipartParser.PartStart((headers @ _)), (s @ _)) =&gt; MultipartParser.this.partBodyFileStream[[_]F[_]](s, maxSizeBeforeWrite)(evidence$6, evidence$7).flatMap[[x]F[x], org.http4s.multipart.Part[F], fs2.Stream[F,org.http4s.multipart.MultipartParser.Event]](((x0$2: (fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])) =&gt; x0$2 match {
    case (_1: fs2.Stream[[_]F[_],Byte], _2: fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]): (fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])((body @ _), (rest @ _)) =&gt; fs2.Pull.output1[[x]fs2.Pure[x], org.http4s.multipart.Part[[_]F[_]]](Part.apply[[_]F[_]](headers, body)).as[fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]](rest)
  }))
  case (_1: org.http4s.multipart.MultipartParser.Event, _2: fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]): (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])(((_: org.http4s.multipart.MultipartParser.PartChunk)| MultipartParser.this.PartEnd), _) =&gt; fs2.Pull.raiseError[[_]F[_]](org.http4s.internal.`package`.bug(&quot;Missing PartStart&quot;))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$6))
}))(fs2.this.Pull.monadErrorInstance[[_]F[_], org.http4s.multipart.Part[F]]))))).apply(x$21)
        </td>
      </tr><tr>
        <td>
          527
        </td>
        <td>
          21676
        </td>
        <td>
          16884
          -
          17471
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Pull.StreamPullOps.stream
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Pull.StreamPullOps[[_]F[_], org.http4s.multipart.Part[F]](fs2.Pull.loop[F, org.http4s.multipart.Part[F], fs2.Stream[F,org.http4s.multipart.MultipartParser.Event]](((x$19: fs2.Stream[F,org.http4s.multipart.MultipartParser.Event]) =&gt; fs2.this.Stream.InvariantOps[[_]F[_], org.http4s.multipart.MultipartParser.Event](x$19).pull.uncons1.flatMap[[x]F[x], org.http4s.multipart.Part[F], Option[fs2.Stream[F,org.http4s.multipart.MultipartParser.Event]]](((x$20: Option[(org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])]) =&gt; cats.syntax.`package`.all.toTraverseOps[Option, (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])](x$20)(cats.this.UnorderedFoldable.catsTraverseForOption).traverse[[+R]fs2.Pull[[_]F[_],org.http4s.multipart.Part[F],R], fs2.Stream[F,org.http4s.multipart.MultipartParser.Event]](((x0$1: (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])) =&gt; x0$1 match {
  case (_1: org.http4s.multipart.MultipartParser.Event, _2: fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]): (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])((value: org.http4s.Headers): org.http4s.multipart.MultipartParser.PartStart((headers @ _)), (s @ _)) =&gt; MultipartParser.this.partBodyFileStream[[_]F[_]](s, maxSizeBeforeWrite)(evidence$6, evidence$7).flatMap[[x]F[x], org.http4s.multipart.Part[F], fs2.Stream[F,org.http4s.multipart.MultipartParser.Event]](((x0$2: (fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])) =&gt; x0$2 match {
    case (_1: fs2.Stream[[_]F[_],Byte], _2: fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]): (fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])((body @ _), (rest @ _)) =&gt; fs2.Pull.output1[[x]fs2.Pure[x], org.http4s.multipart.Part[[_]F[_]]](Part.apply[[_]F[_]](headers, body)).as[fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]](rest)
  }))
  case (_1: org.http4s.multipart.MultipartParser.Event, _2: fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]): (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])(((_: org.http4s.multipart.MultipartParser.PartChunk)| MultipartParser.this.PartEnd), _) =&gt; fs2.Pull.raiseError[[_]F[_]](org.http4s.internal.`package`.bug(&quot;Missing PartStart&quot;))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$6))
}))(fs2.this.Pull.monadErrorInstance[[_]F[_], org.http4s.multipart.Part[F]]))))).apply(x$21)).stream
        </td>
      </tr><tr>
        <td>
          533
        </td>
        <td>
          19364
        </td>
        <td>
          17477
          -
          17608
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.through
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          x$22.through[[x]F[x], org.http4s.multipart.MultipartParser.Event](MultipartParser.this.parseEvents[F](boundary, limit)(evidence$6)).through[[x]F[x], org.http4s.multipart.MultipartParser.Event](MultipartParser.this.limitParts[F](maxParts, failOnLimit)(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$6))).through[[x]F[x], org.http4s.multipart.Part[F]](pullParts)
        </td>
      </tr><tr>
        <td>
          541
        </td>
        <td>
          22583
        </td>
        <td>
          17830
          -
          18283
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Stream.InvariantOps[[_]F[_], org.http4s.multipart.MultipartParser.Event](st).pull.uncons1.flatMap[[x]F[x], org.http4s.multipart.MultipartParser.Event, Unit](((x0$1: Option[(org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])]) =&gt; x0$1 match {
  case (value: (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])): Some[(org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])]((_1: org.http4s.multipart.MultipartParser.Event, _2: fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]): (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])((event @ (_: org.http4s.multipart.MultipartParser.PartStart)), (rest @ _))) =&gt; if (partsCounter.&lt;(maxParts))
    fs2.Pull.output1[[x]fs2.Pure[x], org.http4s.multipart.MultipartParser.PartStart](event).&gt;&gt;[[_]F[_], org.http4s.multipart.MultipartParser.Event, Unit](go(rest, partsCounter.+(1)))
  else
    if (failOnLimit)
      fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply(&quot;Parts limit exceeded&quot;, MalformedMessageBodyFailure.apply$default$2))(evidence$8)
    else
      fs2.Pull.done
  case (value: (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])): Some[(org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])]((_1: org.http4s.multipart.MultipartParser.Event, _2: fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]): (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])((event @ _), (rest @ _))) =&gt; fs2.Pull.output1[[x]fs2.Pure[x], org.http4s.multipart.MultipartParser.Event](event).&gt;&gt;[[_]F[_], org.http4s.multipart.MultipartParser.Event, Unit](go(rest, partsCounter))
  case scala.None =&gt; fs2.Pull.done
}))
        </td>
      </tr><tr>
        <td>
          543
        </td>
        <td>
          15641
        </td>
        <td>
          17917
          -
          17940
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          partsCounter.&lt;(maxParts)
        </td>
      </tr><tr>
        <td>
          544
        </td>
        <td>
          22540
        </td>
        <td>
          17988
          -
          18004
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          partsCounter.+(1)
        </td>
      </tr><tr>
        <td>
          544
        </td>
        <td>
          16145
        </td>
        <td>
          17956
          -
          18005
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.&gt;&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.output1[[x]fs2.Pure[x], org.http4s.multipart.MultipartParser.PartStart](event).&gt;&gt;[[_]F[_], org.http4s.multipart.MultipartParser.Event, Unit](go(rest, partsCounter.+(1)))
        </td>
      </tr><tr>
        <td>
          544
        </td>
        <td>
          22569
        </td>
        <td>
          17956
          -
          18005
        </td>
        <td>
          Block
        </td>
        <td>
          fs2.Pull.&gt;&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.output1[[x]fs2.Pure[x], org.http4s.multipart.MultipartParser.PartStart](event).&gt;&gt;[[_]F[_], org.http4s.multipart.MultipartParser.Event, Unit](go(rest, partsCounter.+(1)))
        </td>
      </tr><tr>
        <td>
          544
        </td>
        <td>
          18692
        </td>
        <td>
          17979
          -
          18005
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.go
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          go(rest, partsCounter.+(1))
        </td>
      </tr><tr>
        <td>
          545
        </td>
        <td>
          15500
        </td>
        <td>
          18023
          -
          18152
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (failOnLimit)
  fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply(&quot;Parts limit exceeded&quot;, MalformedMessageBodyFailure.apply$default$2))(evidence$8)
else
  fs2.Pull.done
        </td>
      </tr><tr>
        <td>
          546
        </td>
        <td>
          15472
        </td>
        <td>
          18054
          -
          18125
        </td>
        <td>
          Block
        </td>
        <td>
          fs2.Pull.raiseError
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply(&quot;Parts limit exceeded&quot;, MalformedMessageBodyFailure.apply$default$2))(evidence$8)
        </td>
      </tr><tr>
        <td>
          546
        </td>
        <td>
          18862
        </td>
        <td>
          18054
          -
          18125
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.Pull.raiseError
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply(&quot;Parts limit exceeded&quot;, MalformedMessageBodyFailure.apply$default$2))(evidence$8)
        </td>
      </tr><tr>
        <td>
          547
        </td>
        <td>
          19380
        </td>
        <td>
          18143
          -
          18152
        </td>
        <td>
          Block
        </td>
        <td>
          fs2.Pull.done
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.done
        </td>
      </tr><tr>
        <td>
          547
        </td>
        <td>
          21886
        </td>
        <td>
          18143
          -
          18152
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Pull.done
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.done
        </td>
      </tr><tr>
        <td>
          549
        </td>
        <td>
          22402
        </td>
        <td>
          18222
          -
          18244
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.go
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          go(rest, partsCounter)
        </td>
      </tr><tr>
        <td>
          549
        </td>
        <td>
          18707
        </td>
        <td>
          18199
          -
          18244
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.&gt;&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.output1[[x]fs2.Pure[x], org.http4s.multipart.MultipartParser.Event](event).&gt;&gt;[[_]F[_], org.http4s.multipart.MultipartParser.Event, Unit](go(rest, partsCounter))
        </td>
      </tr><tr>
        <td>
          550
        </td>
        <td>
          16370
        </td>
        <td>
          18266
          -
          18275
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Pull.done
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.done
        </td>
      </tr><tr>
        <td>
          553
        </td>
        <td>
          15335
        </td>
        <td>
          18289
          -
          18304
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Pull.StreamPullOps.stream
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Pull.StreamPullOps[[_]F[_], org.http4s.multipart.MultipartParser.Event](go(x$23, 0)).stream
        </td>
      </tr><tr>
        <td>
          553
        </td>
        <td>
          19227
        </td>
        <td>
          18289
          -
          18297
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.go
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          go(x$23, 0)
        </td>
      </tr><tr>
        <td>
          568
        </td>
        <td>
          21648
        </td>
        <td>
          18875
          -
          18901
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&gt;=
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          limitCTR.&gt;=(maxBeforeWrite)
        </td>
      </tr><tr>
        <td>
          571
        </td>
        <td>
          19625
        </td>
        <td>
          18985
          -
          18997
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.io.file.Flags.Append
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.io.file.Flags.Append
        </td>
      </tr><tr>
        <td>
          571
        </td>
        <td>
          15518
        </td>
        <td>
          18958
          -
          18998
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.io.file.Files.writeAll
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.io.file.Files.apply[F](evidence$10).writeAll(fileRef, fs2.io.file.Flags.Append)
        </td>
      </tr><tr>
        <td>
          572
        </td>
        <td>
          18586
        </td>
        <td>
          19013
          -
          19013
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.CompilerLowPriority1.target
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.this.Compiler.target[[x]F[x]](Compiler.this.Target.forConcurrent[[x]F[x]](evidence$9))
        </td>
      </tr><tr>
        <td>
          572
        </td>
        <td>
          22419
        </td>
        <td>
          19013
          -
          19013
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.Compiler.Target.forConcurrent
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Compiler.this.Target.forConcurrent[[x]F[x]](evidence$9)
        </td>
      </tr><tr>
        <td>
          573
        </td>
        <td>
          14586
        </td>
        <td>
          18932
          -
          19039
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Stream.CompileOps.drain
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          lacc.through[[_]F[_], fs2.INothing](fs2.io.file.Files.apply[F](evidence$10).writeAll(fileRef, fs2.io.file.Flags.Append)).compile[[x]F[x], [x]F[x], fs2.INothing](fs2.this.Compiler.target[[x]F[x]](Compiler.this.Target.forConcurrent[[x]F[x]](evidence$9))).drain
        </td>
      </tr><tr>
        <td>
          574
        </td>
        <td>
          21513
        </td>
        <td>
          18911
          -
          19096
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.&gt;&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.Pull.eval[F, Unit](lacc.through[[_]F[_], fs2.INothing](fs2.io.file.Files.apply[F](evidence$10).writeAll(fileRef, fs2.io.file.Flags.Append)).compile[[x]F[x], [x]F[x], fs2.INothing](fs2.this.Compiler.target[[x]F[x]](Compiler.this.Target.forConcurrent[[x]F[x]](evidence$9))).drain).&gt;&gt;[[x]F[x], fs2.INothing, fs2.Stream[F,org.http4s.multipart.MultipartParser.Event]](streamAndWrite(s, fs2.Stream.empty, 0, fileRef))
        </td>
      </tr><tr>
        <td>
          574
        </td>
        <td>
          19114
        </td>
        <td>
          19085
          -
          19086
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0
        </td>
      </tr><tr>
        <td>
          574
        </td>
        <td>
          15355
        </td>
        <td>
          19053
          -
          19096
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.streamAndWrite
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          streamAndWrite(s, fs2.Stream.empty, 0, fileRef)
        </td>
      </tr><tr>
        <td>
          574
        </td>
        <td>
          22975
        </td>
        <td>
          19071
          -
          19083
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Stream.empty
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.Stream.empty
        </td>
      </tr><tr>
        <td>
          574
        </td>
        <td>
          19649
        </td>
        <td>
          18911
          -
          19096
        </td>
        <td>
          Block
        </td>
        <td>
          fs2.Pull.&gt;&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.Pull.eval[F, Unit](lacc.through[[_]F[_], fs2.INothing](fs2.io.file.Files.apply[F](evidence$10).writeAll(fileRef, fs2.io.file.Flags.Append)).compile[[x]F[x], [x]F[x], fs2.INothing](fs2.this.Compiler.target[[x]F[x]](Compiler.this.Target.forConcurrent[[x]F[x]](evidence$9))).drain).&gt;&gt;[[x]F[x], fs2.INothing, fs2.Stream[F,org.http4s.multipart.MultipartParser.Event]](streamAndWrite(s, fs2.Stream.empty, 0, fileRef))
        </td>
      </tr><tr>
        <td>
          576
        </td>
        <td>
          15493
        </td>
        <td>
          19116
          -
          19722
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.this.Stream.InvariantOps[[_]F[_], org.http4s.multipart.MultipartParser.Event](s).pull.uncons1.flatMap[[x]F[x], fs2.INothing, fs2.Stream[F,org.http4s.multipart.MultipartParser.Event]](((x0$1: Option[(org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])]) =&gt; x0$1 match {
  case (value: (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])): Some[(org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])]((_1: org.http4s.multipart.MultipartParser.Event, _2: fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]): (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])((value: fs2.Chunk[Byte]): org.http4s.multipart.MultipartParser.PartChunk((chnk @ _)), (str @ _))) =&gt; streamAndWrite(str, lacc.++[[x]fs2.Pure[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](chnk)), limitCTR.+(chnk.size), fileRef)
  case (value: (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])): Some[(org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])]((_1: org.http4s.multipart.MultipartParser.Event, _2: fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]): (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])(MultipartParser.this.PartEnd, (str @ _))) =&gt; fs2.Pull.eval[F, Unit](lacc.through[[_]F[_], fs2.INothing](fs2.io.file.Files.apply[F](evidence$10).writeAll(fileRef, fs2.io.file.Flags.Append)).compile[[x]F[x], [x]F[x], fs2.INothing](fs2.this.Compiler.target[[x]F[x]](Compiler.this.Target.forConcurrent[[x]F[x]](evidence$9))).drain).as[fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]](str)
  case ((value: (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])): Some[(org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])]((_1: org.http4s.multipart.MultipartParser.Event, _2: fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]): (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])((_: org.http4s.multipart.MultipartParser.PartStart), _))| scala.None) =&gt; fs2.Pull.raiseError[[_]F[_]](org.http4s.internal.`package`.bug(&quot;Missing PartEnd&quot;))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$9))
}))
        </td>
      </tr><tr>
        <td>
          576
        </td>
        <td>
          22039
        </td>
        <td>
          19116
          -
          19722
        </td>
        <td>
          Block
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.this.Stream.InvariantOps[[_]F[_], org.http4s.multipart.MultipartParser.Event](s).pull.uncons1.flatMap[[x]F[x], fs2.INothing, fs2.Stream[F,org.http4s.multipart.MultipartParser.Event]](((x0$1: Option[(org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])]) =&gt; x0$1 match {
  case (value: (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])): Some[(org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])]((_1: org.http4s.multipart.MultipartParser.Event, _2: fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]): (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])((value: fs2.Chunk[Byte]): org.http4s.multipart.MultipartParser.PartChunk((chnk @ _)), (str @ _))) =&gt; streamAndWrite(str, lacc.++[[x]fs2.Pure[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](chnk)), limitCTR.+(chnk.size), fileRef)
  case (value: (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])): Some[(org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])]((_1: org.http4s.multipart.MultipartParser.Event, _2: fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]): (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])(MultipartParser.this.PartEnd, (str @ _))) =&gt; fs2.Pull.eval[F, Unit](lacc.through[[_]F[_], fs2.INothing](fs2.io.file.Files.apply[F](evidence$10).writeAll(fileRef, fs2.io.file.Flags.Append)).compile[[x]F[x], [x]F[x], fs2.INothing](fs2.this.Compiler.target[[x]F[x]](Compiler.this.Target.forConcurrent[[x]F[x]](evidence$9))).drain).as[fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]](str)
  case ((value: (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])): Some[(org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])]((_1: org.http4s.multipart.MultipartParser.Event, _2: fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]): (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])((_: org.http4s.multipart.MultipartParser.PartStart), _))| scala.None) =&gt; fs2.Pull.raiseError[[_]F[_]](org.http4s.internal.`package`.bug(&quot;Missing PartEnd&quot;))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$9))
}))
        </td>
      </tr><tr>
        <td>
          578
        </td>
        <td>
          14446
        </td>
        <td>
          19248
          -
          19268
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.+
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          limitCTR.+(chnk.size)
        </td>
      </tr><tr>
        <td>
          578
        </td>
        <td>
          15638
        </td>
        <td>
          19228
          -
          19246
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.chunk
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.Stream.chunk[[x]fs2.Pure[x], Byte](chnk)
        </td>
      </tr><tr>
        <td>
          578
        </td>
        <td>
          18608
        </td>
        <td>
          19259
          -
          19268
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Chunk.size
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          chnk.size
        </td>
      </tr><tr>
        <td>
          578
        </td>
        <td>
          22289
        </td>
        <td>
          19220
          -
          19246
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.++
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          lacc.++[[x]fs2.Pure[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](chnk))
        </td>
      </tr><tr>
        <td>
          578
        </td>
        <td>
          22860
        </td>
        <td>
          19200
          -
          19278
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.streamAndWrite
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          streamAndWrite(str, lacc.++[[x]fs2.Pure[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](chnk)), limitCTR.+(chnk.size), fileRef)
        </td>
      </tr><tr>
        <td>
          587
        </td>
        <td>
          18858
        </td>
        <td>
          19330
          -
          19536
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.as
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.Pull.eval[F, Unit](lacc.through[[_]F[_], fs2.INothing](fs2.io.file.Files.apply[F](evidence$10).writeAll(fileRef, fs2.io.file.Flags.Append)).compile[[x]F[x], [x]F[x], fs2.INothing](fs2.this.Compiler.target[[x]F[x]](Compiler.this.Target.forConcurrent[[x]F[x]](evidence$9))).drain).as[fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]](str)
        </td>
      </tr><tr>
        <td>
          590
        </td>
        <td>
          17834
        </td>
        <td>
          19673
          -
          19712
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.Pull.raiseError
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.Pull.raiseError[[_]F[_]](org.http4s.internal.`package`.bug(&quot;Missing PartEnd&quot;))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$9))
        </td>
      </tr><tr>
        <td>
          590
        </td>
        <td>
          14933
        </td>
        <td>
          19689
          -
          19711
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.internal.bug
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.http4s.internal.`package`.bug(&quot;Missing PartEnd&quot;)
        </td>
      </tr><tr>
        <td>
          590
        </td>
        <td>
          21532
        </td>
        <td>
          19688
          -
          19688
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.RaiseThrowable.fromApplicativeError
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$9)
        </td>
      </tr><tr>
        <td>
          601
        </td>
        <td>
          18558
        </td>
        <td>
          20102
          -
          20128
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&gt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          limitCTR.&gt;=(maxBeforeWrite)
        </td>
      </tr><tr>
        <td>
          603
        </td>
        <td>
          14469
        </td>
        <td>
          20159
          -
          20206
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          cats.effect.kernel.Resource.allocated
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.io.file.Files.apply[F](evidence$10).tempFile(scala.None, &quot;&quot;, &quot;&quot;, scala.None).allocated[fs2.io.file.Path](evidence$9)
        </td>
      </tr><tr>
        <td>
          604
        </td>
        <td>
          23101
        </td>
        <td>
          20138
          -
          20473
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.Pull.eval[F, (fs2.io.file.Path, F[Unit])](fs2.io.file.Files.apply[F](evidence$10).tempFile(scala.None, &quot;&quot;, &quot;&quot;, scala.None).allocated[fs2.io.file.Path](evidence$9)).flatMap[[x]F[x], fs2.INothing, (fs2.Stream[F,Byte], fs2.Stream[F,org.http4s.multipart.MultipartParser.Event])](((x0$1: (fs2.io.file.Path, F[Unit])) =&gt; x0$1 match {
  case (_1: fs2.io.file.Path, _2: F[Unit]): (fs2.io.file.Path, F[Unit])((path @ _), (cleanup @ _)) =&gt; cats.syntax.`package`.all.catsSyntaxApplicativeError[[+R]fs2.Pull[F,Nothing,R], Throwable, (fs2.Stream[[x]F[x],Byte], fs2.Stream[F,org.http4s.multipart.MultipartParser.Event])](cats.syntax.`package`.all.toFunctorOps[[+R]fs2.Pull[F,Nothing,R], fs2.Stream[F,org.http4s.multipart.MultipartParser.Event]](streamAndWrite(s, lacc, limitCTR, path))(fs2.this.Pull.monadErrorInstance[[_]F[_], Nothing]).tupleLeft[fs2.Stream[[x]F[x],Byte]](fs2.io.file.Files.apply[F](evidence$10).readAll(path, maxBeforeWrite, fs2.io.file.Flags.Read).onFinalizeWeak[[x]F[x]](cleanup)(evidence$9)))(fs2.this.Pull.monadErrorInstance[[_]F[_], Nothing]).onError(({
    @SerialVersionUID(value = 0) final &lt;synthetic&gt; class $anonfun extends scala.runtime.AbstractPartialFunction[Throwable,fs2.Pull[F,Nothing,Unit]] with java.io.Serializable {
      def &lt;init&gt;(): &lt;$anon: Throwable =&gt; fs2.Pull[F,Nothing,Unit]&gt; = {
        $anonfun.super.&lt;init&gt;();
        ()
      };
      final override def applyOrElse[A1 &lt;: Throwable, B1 &gt;: fs2.Pull[F,Nothing,Unit]](x1: A1, default: A1 =&gt; B1): B1 = ((x1.asInstanceOf[Throwable]: Throwable): Throwable @unchecked) match {
        case _ =&gt; fs2.Pull.eval[F, Unit](cleanup)
        case (defaultCase$ @ _) =&gt; default.apply(x1)
      };
      final def isDefinedAt(x1: Throwable): Boolean = ((x1.asInstanceOf[Throwable]: Throwable): Throwable @unchecked) match {
        case _ =&gt; true
        case (defaultCase$ @ _) =&gt; false
      }
    };
    new $anonfun()
  }: PartialFunction[Throwable,fs2.Pull[F,Nothing,Unit]]))(fs2.this.Pull.monadErrorInstance[[_]F[_], Nothing])
}))
        </td>
      </tr><tr>
        <td>
          604
        </td>
        <td>
          18748
        </td>
        <td>
          20138
          -
          20473
        </td>
        <td>
          Block
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.Pull.eval[F, (fs2.io.file.Path, F[Unit])](fs2.io.file.Files.apply[F](evidence$10).tempFile(scala.None, &quot;&quot;, &quot;&quot;, scala.None).allocated[fs2.io.file.Path](evidence$9)).flatMap[[x]F[x], fs2.INothing, (fs2.Stream[F,Byte], fs2.Stream[F,org.http4s.multipart.MultipartParser.Event])](((x0$1: (fs2.io.file.Path, F[Unit])) =&gt; x0$1 match {
  case (_1: fs2.io.file.Path, _2: F[Unit]): (fs2.io.file.Path, F[Unit])((path @ _), (cleanup @ _)) =&gt; cats.syntax.`package`.all.catsSyntaxApplicativeError[[+R]fs2.Pull[F,Nothing,R], Throwable, (fs2.Stream[[x]F[x],Byte], fs2.Stream[F,org.http4s.multipart.MultipartParser.Event])](cats.syntax.`package`.all.toFunctorOps[[+R]fs2.Pull[F,Nothing,R], fs2.Stream[F,org.http4s.multipart.MultipartParser.Event]](streamAndWrite(s, lacc, limitCTR, path))(fs2.this.Pull.monadErrorInstance[[_]F[_], Nothing]).tupleLeft[fs2.Stream[[x]F[x],Byte]](fs2.io.file.Files.apply[F](evidence$10).readAll(path, maxBeforeWrite, fs2.io.file.Flags.Read).onFinalizeWeak[[x]F[x]](cleanup)(evidence$9)))(fs2.this.Pull.monadErrorInstance[[_]F[_], Nothing]).onError(({
    @SerialVersionUID(value = 0) final &lt;synthetic&gt; class $anonfun extends scala.runtime.AbstractPartialFunction[Throwable,fs2.Pull[F,Nothing,Unit]] with java.io.Serializable {
      def &lt;init&gt;(): &lt;$anon: Throwable =&gt; fs2.Pull[F,Nothing,Unit]&gt; = {
        $anonfun.super.&lt;init&gt;();
        ()
      };
      final override def applyOrElse[A1 &lt;: Throwable, B1 &gt;: fs2.Pull[F,Nothing,Unit]](x1: A1, default: A1 =&gt; B1): B1 = ((x1.asInstanceOf[Throwable]: Throwable): Throwable @unchecked) match {
        case _ =&gt; fs2.Pull.eval[F, Unit](cleanup)
        case (defaultCase$ @ _) =&gt; default.apply(x1)
      };
      final def isDefinedAt(x1: Throwable): Boolean = ((x1.asInstanceOf[Throwable]: Throwable): Throwable @unchecked) match {
        case _ =&gt; true
        case (defaultCase$ @ _) =&gt; false
      }
    };
    new $anonfun()
  }: PartialFunction[Throwable,fs2.Pull[F,Nothing,Unit]]))(fs2.this.Pull.monadErrorInstance[[_]F[_], Nothing])
}))
        </td>
      </tr><tr>
        <td>
          605
        </td>
        <td>
          22580
        </td>
        <td>
          20265
          -
          20304
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.streamAndWrite
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          streamAndWrite(s, lacc, limitCTR, path)
        </td>
      </tr><tr>
        <td>
          605
        </td>
        <td>
          18728
        </td>
        <td>
          20279
          -
          20279
        </td>
        <td>
          TypeApply
        </td>
        <td>
          fs2.PullLowPriority.monadErrorInstance
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.this.Pull.monadErrorInstance[[_]F[_], Nothing]
        </td>
      </tr><tr>
        <td>
          606
        </td>
        <td>
          17715
        </td>
        <td>
          20329
          -
          20329
        </td>
        <td>
          TypeApply
        </td>
        <td>
          fs2.PullLowPriority.monadErrorInstance
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.this.Pull.monadErrorInstance[[_]F[_], Nothing]
        </td>
      </tr><tr>
        <td>
          606
        </td>
        <td>
          21776
        </td>
        <td>
          20265
          -
          20405
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.Functor.Ops.tupleLeft
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          cats.syntax.`package`.all.toFunctorOps[[+R]fs2.Pull[F,Nothing,R], fs2.Stream[F,org.http4s.multipart.MultipartParser.Event]](streamAndWrite(s, lacc, limitCTR, path))(fs2.this.Pull.monadErrorInstance[[_]F[_], Nothing]).tupleLeft[fs2.Stream[[x]F[x],Byte]](fs2.io.file.Files.apply[F](evidence$10).readAll(path, maxBeforeWrite, fs2.io.file.Flags.Read).onFinalizeWeak[[x]F[x]](cleanup)(evidence$9))
        </td>
      </tr><tr>
        <td>
          606
        </td>
        <td>
          14953
        </td>
        <td>
          20330
          -
          20404
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.Stream.onFinalizeWeak
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.io.file.Files.apply[F](evidence$10).readAll(path, maxBeforeWrite, fs2.io.file.Flags.Read).onFinalizeWeak[[x]F[x]](cleanup)(evidence$9)
        </td>
      </tr><tr>
        <td>
          607
        </td>
        <td>
          18577
        </td>
        <td>
          20429
          -
          20429
        </td>
        <td>
          TypeApply
        </td>
        <td>
          fs2.PullLowPriority.monadErrorInstance
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.this.Pull.monadErrorInstance[[_]F[_], Nothing]
        </td>
      </tr><tr>
        <td>
          607
        </td>
        <td>
          21925
        </td>
        <td>
          20429
          -
          20429
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.$anonfun.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          new $anonfun()
        </td>
      </tr><tr>
        <td>
          607
        </td>
        <td>
          15513
        </td>
        <td>
          20441
          -
          20459
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.eval
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.Pull.eval[F, Unit](cleanup)
        </td>
      </tr><tr>
        <td>
          607
        </td>
        <td>
          14821
        </td>
        <td>
          20265
          -
          20461
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          cats.syntax.ApplicativeErrorOps.onError
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          cats.syntax.`package`.all.catsSyntaxApplicativeError[[+R]fs2.Pull[F,Nothing,R], Throwable, (fs2.Stream[[x]F[x],Byte], fs2.Stream[F,org.http4s.multipart.MultipartParser.Event])](cats.syntax.`package`.all.toFunctorOps[[+R]fs2.Pull[F,Nothing,R], fs2.Stream[F,org.http4s.multipart.MultipartParser.Event]](streamAndWrite(s, lacc, limitCTR, path))(fs2.this.Pull.monadErrorInstance[[_]F[_], Nothing]).tupleLeft[fs2.Stream[[x]F[x],Byte]](fs2.io.file.Files.apply[F](evidence$10).readAll(path, maxBeforeWrite, fs2.io.file.Flags.Read).onFinalizeWeak[[x]F[x]](cleanup)(evidence$9)))(fs2.this.Pull.monadErrorInstance[[_]F[_], Nothing]).onError(({
  @SerialVersionUID(value = 0) final &lt;synthetic&gt; class $anonfun extends scala.runtime.AbstractPartialFunction[Throwable,fs2.Pull[F,Nothing,Unit]] with java.io.Serializable {
    def &lt;init&gt;(): &lt;$anon: Throwable =&gt; fs2.Pull[F,Nothing,Unit]&gt; = {
      $anonfun.super.&lt;init&gt;();
      ()
    };
    final override def applyOrElse[A1 &lt;: Throwable, B1 &gt;: fs2.Pull[F,Nothing,Unit]](x1: A1, default: A1 =&gt; B1): B1 = ((x1.asInstanceOf[Throwable]: Throwable): Throwable @unchecked) match {
      case _ =&gt; fs2.Pull.eval[F, Unit](cleanup)
      case (defaultCase$ @ _) =&gt; default.apply(x1)
    };
    final def isDefinedAt(x1: Throwable): Boolean = ((x1.asInstanceOf[Throwable]: Throwable): Throwable @unchecked) match {
      case _ =&gt; true
      case (defaultCase$ @ _) =&gt; false
    }
  };
  new $anonfun()
}: PartialFunction[Throwable,fs2.Pull[F,Nothing,Unit]]))(fs2.this.Pull.monadErrorInstance[[_]F[_], Nothing])
        </td>
      </tr><tr>
        <td>
          610
        </td>
        <td>
          17685
        </td>
        <td>
          20493
          -
          20894
        </td>
        <td>
          Block
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Stream.InvariantOps[[_]F[_], org.http4s.multipart.MultipartParser.Event](s).pull.uncons1.flatMap[[x]F[x], fs2.INothing, (fs2.Stream[F,Byte], fs2.Stream[F,org.http4s.multipart.MultipartParser.Event])](((x0$2: Option[(org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])]) =&gt; x0$2 match {
  case (value: (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])): Some[(org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])]((_1: org.http4s.multipart.MultipartParser.Event, _2: fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]): (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])((value: fs2.Chunk[Byte]): org.http4s.multipart.MultipartParser.PartChunk((chnk @ _)), (str @ _))) =&gt; go(str, lacc.++[[x]fs2.Pure[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](chnk)), limitCTR.+(chnk.size))
  case (value: (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])): Some[(org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])]((_1: org.http4s.multipart.MultipartParser.Event, _2: fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]): (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])(MultipartParser.this.PartEnd, (str @ _))) =&gt; fs2.Pull.pure[Nothing, (fs2.Stream[fs2.Pure,Byte], fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])](scala.Tuple2.apply[fs2.Stream[fs2.Pure,Byte], fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]](lacc, str))
  case ((value: (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])): Some[(org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])]((_1: org.http4s.multipart.MultipartParser.Event, _2: fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]): (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])((_: org.http4s.multipart.MultipartParser.PartStart), _))| scala.None) =&gt; fs2.Pull.raiseError[[_]F[_]](org.http4s.internal.`package`.bug(&quot;Missing PartEnd&quot;))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$9))
}))
        </td>
      </tr><tr>
        <td>
          610
        </td>
        <td>
          21812
        </td>
        <td>
          20493
          -
          20894
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Stream.InvariantOps[[_]F[_], org.http4s.multipart.MultipartParser.Event](s).pull.uncons1.flatMap[[x]F[x], fs2.INothing, (fs2.Stream[F,Byte], fs2.Stream[F,org.http4s.multipart.MultipartParser.Event])](((x0$2: Option[(org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])]) =&gt; x0$2 match {
  case (value: (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])): Some[(org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])]((_1: org.http4s.multipart.MultipartParser.Event, _2: fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]): (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])((value: fs2.Chunk[Byte]): org.http4s.multipart.MultipartParser.PartChunk((chnk @ _)), (str @ _))) =&gt; go(str, lacc.++[[x]fs2.Pure[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](chnk)), limitCTR.+(chnk.size))
  case (value: (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])): Some[(org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])]((_1: org.http4s.multipart.MultipartParser.Event, _2: fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]): (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])(MultipartParser.this.PartEnd, (str @ _))) =&gt; fs2.Pull.pure[Nothing, (fs2.Stream[fs2.Pure,Byte], fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])](scala.Tuple2.apply[fs2.Stream[fs2.Pure,Byte], fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]](lacc, str))
  case ((value: (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])): Some[(org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])]((_1: org.http4s.multipart.MultipartParser.Event, _2: fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]): (org.http4s.multipart.MultipartParser.Event, fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])((_: org.http4s.multipart.MultipartParser.PartStart), _))| scala.None) =&gt; fs2.Pull.raiseError[[_]F[_]](org.http4s.internal.`package`.bug(&quot;Missing PartEnd&quot;))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$9))
}))
        </td>
      </tr><tr>
        <td>
          612
        </td>
        <td>
          21794
        </td>
        <td>
          20585
          -
          20611
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          lacc.++[[x]fs2.Pure[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](chnk))
        </td>
      </tr><tr>
        <td>
          612
        </td>
        <td>
          21943
        </td>
        <td>
          20577
          -
          20634
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.go
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          go(str, lacc.++[[x]fs2.Pure[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](chnk)), limitCTR.+(chnk.size))
        </td>
      </tr><tr>
        <td>
          612
        </td>
        <td>
          15193
        </td>
        <td>
          20593
          -
          20611
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.chunk
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.chunk[[x]fs2.Pure[x], Byte](chnk)
        </td>
      </tr><tr>
        <td>
          612
        </td>
        <td>
          16030
        </td>
        <td>
          20613
          -
          20633
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          limitCTR.+(chnk.size)
        </td>
      </tr><tr>
        <td>
          612
        </td>
        <td>
          17812
        </td>
        <td>
          20624
          -
          20633
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Chunk.size
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          chnk.size
        </td>
      </tr><tr>
        <td>
          614
        </td>
        <td>
          18601
        </td>
        <td>
          20696
          -
          20707
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[fs2.Stream[fs2.Pure,Byte], fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]](lacc, str)
        </td>
      </tr><tr>
        <td>
          614
        </td>
        <td>
          14722
        </td>
        <td>
          20686
          -
          20708
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.pure
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.pure[Nothing, (fs2.Stream[fs2.Pure,Byte], fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event])](scala.Tuple2.apply[fs2.Stream[fs2.Pure,Byte], fs2.Stream[[_]F[_],org.http4s.multipart.MultipartParser.Event]](lacc, str))
        </td>
      </tr><tr>
        <td>
          617
        </td>
        <td>
          20993
        </td>
        <td>
          20861
          -
          20883
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.internal.bug
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.http4s.internal.`package`.bug(&quot;Missing PartEnd&quot;)
        </td>
      </tr><tr>
        <td>
          617
        </td>
        <td>
          15209
        </td>
        <td>
          20845
          -
          20884
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.Pull.raiseError
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.Pull.raiseError[[_]F[_]](org.http4s.internal.`package`.bug(&quot;Missing PartEnd&quot;))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$9))
        </td>
      </tr><tr>
        <td>
          617
        </td>
        <td>
          19253
        </td>
        <td>
          20860
          -
          20860
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.RaiseThrowable.fromApplicativeError
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$9)
        </td>
      </tr><tr>
        <td>
          620
        </td>
        <td>
          22172
        </td>
        <td>
          20925
          -
          20926
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          620
        </td>
        <td>
          15791
        </td>
        <td>
          20911
          -
          20923
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Stream.empty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.empty
        </td>
      </tr><tr>
        <td>
          620
        </td>
        <td>
          18465
        </td>
        <td>
          20900
          -
          20927
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.go
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          go(stream, fs2.Stream.empty, 0)
        </td>
      </tr><tr>
        <td>
          639
        </td>
        <td>
          14461
        </td>
        <td>
          21511
          -
          21685
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          org.http4s.multipart.MultipartParser.parseToPartsSupervisedFile
        </td>
        <td>
          org.http4s.multipart.multipartparsersuite
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.parseToPartsSupervisedFile[[_]F[_]](supervisor, boundary, limit, maxSizeBeforeWrite, maxParts, failOnLimit, chunkSize)(evidence$11, evidence$12)
        </td>
      </tr><tr>
        <td>
          648
        </td>
        <td>
          18994
        </td>
        <td>
          21720
          -
          21726
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.SeqOps.:+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$24.:+[org.http4s.multipart.Part[F]](x$25)
        </td>
      </tr><tr>
        <td>
          648
        </td>
        <td>
          20893
        </td>
        <td>
          21697
          -
          21718
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.Vector.empty
        </td>
        <td>
          org.http4s.multipart.multipartparsersuite
        </td>
        <td style="background: #AEF1AE">
          scala.`package`.Vector.empty[org.http4s.multipart.Part[F]]
        </td>
      </tr><tr>
        <td>
          649
        </td>
        <td>
          21690
        </td>
        <td>
          21493
          -
          21762
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.map
        </td>
        <td>
          org.http4s.multipart.multipartparsersuite
        </td>
        <td style="background: #AEF1AE">
          st.through[[x]F[x], org.http4s.multipart.Part[[_]F[_]]](MultipartParser.this.parseToPartsSupervisedFile[[_]F[_]](supervisor, boundary, limit, maxSizeBeforeWrite, maxParts, failOnLimit, chunkSize)(evidence$11, evidence$12)).fold[scala.collection.immutable.Vector[org.http4s.multipart.Part[F]]](scala.`package`.Vector.empty[org.http4s.multipart.Part[F]])(((x$24: scala.collection.immutable.Vector[org.http4s.multipart.Part[F]], x$25: org.http4s.multipart.Part[[_]F[_]]) =&gt; x$24.:+[org.http4s.multipart.Part[F]](x$25))).map[org.http4s.multipart.Multipart[[_]F[_]]](((x$26: scala.collection.immutable.Vector[org.http4s.multipart.Part[F]]) =&gt; Multipart.apply[[_]F[_]](x$26, boundary)))
        </td>
      </tr><tr>
        <td>
          649
        </td>
        <td>
          15230
        </td>
        <td>
          21739
          -
          21761
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.Multipart.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Multipart.apply[[_]F[_]](x$26, boundary)
        </td>
      </tr><tr>
        <td>
          661
        </td>
        <td>
          17706
        </td>
        <td>
          22141
          -
          22186
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          org.http4s.multipart.MultipartParser.superviseResource
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.superviseResource[[_]F[_], fs2.io.file.Path](supervisor, files.tempFile)(F)
        </td>
      </tr><tr>
        <td>
          663
        </td>
        <td>
          14327
        </td>
        <td>
          22308
          -
          22308
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.CompilerLowPriority1.target
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Compiler.target[[x]F[x]](Compiler.this.Target.forConcurrent[[x]F[x]](F))
        </td>
      </tr><tr>
        <td>
          663
        </td>
        <td>
          18484
        </td>
        <td>
          22308
          -
          22308
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.Compiler.Target.forConcurrent
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Compiler.this.Target.forConcurrent[[x]F[x]](F)
        </td>
      </tr><tr>
        <td>
          663
        </td>
        <td>
          15657
        </td>
        <td>
          22293
          -
          22305
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.io.file.Flags.Append
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.io.file.Flags.Append
        </td>
      </tr><tr>
        <td>
          663
        </td>
        <td>
          21919
        </td>
        <td>
          22272
          -
          22306
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.io.file.Files.writeAll
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          files.writeAll(file, fs2.io.file.Flags.Append)
        </td>
      </tr><tr>
        <td>
          663
        </td>
        <td>
          20913
        </td>
        <td>
          22258
          -
          22321
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Stream.CompileOps.drain
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bytes.through[[_]F[_], fs2.INothing](files.writeAll(file, fs2.io.file.Flags.Append)).compile[[x]F[x], [x]F[x], fs2.INothing](fs2.this.Compiler.target[[x]F[x]](Compiler.this.Target.forConcurrent[[x]F[x]](F))).drain
        </td>
      </tr><tr>
        <td>
          668
        </td>
        <td>
          19229
        </td>
        <td>
          22518
          -
          22528
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Chunk.size
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          chunk.size
        </td>
      </tr><tr>
        <td>
          668
        </td>
        <td>
          14845
        </td>
        <td>
          22499
          -
          22528
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          oldAcc.bytesSize.+(chunk.size)
        </td>
      </tr><tr>
        <td>
          669
        </td>
        <td>
          17578
        </td>
        <td>
          22550
          -
          22585
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          oldAcc.bytes.++[[x]fs2.Pure[x], Byte](fs2.Stream.chunk[[x]fs2.Pure[x], Byte](chunk))
        </td>
      </tr><tr>
        <td>
          669
        </td>
        <td>
          21710
        </td>
        <td>
          22566
          -
          22585
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.chunk
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.chunk[[x]fs2.Pure[x], Byte](chunk)
        </td>
      </tr><tr>
        <td>
          670
        </td>
        <td>
          13806
        </td>
        <td>
          22596
          -
          22624
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          newSize.&gt;(maxSizeBeforeWrite)
        </td>
      </tr><tr>
        <td>
          672
        </td>
        <td>
          18077
        </td>
        <td>
          22636
          -
          22683
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.fold
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          oldAcc.file.fold[F[fs2.io.file.Path]](createFile)(((x: fs2.io.file.Path) =&gt; F.pure[fs2.io.file.Path](x)))
        </td>
      </tr><tr>
        <td>
          672
        </td>
        <td>
          21940
        </td>
        <td>
          22676
          -
          22682
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.Applicative.pure
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          F.pure[fs2.io.file.Path](x)
        </td>
      </tr><tr>
        <td>
          673
        </td>
        <td>
          14342
        </td>
        <td>
          22703
          -
          22722
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.append
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          append(x$27, newBytes)
        </td>
      </tr><tr>
        <td>
          673
        </td>
        <td>
          20789
        </td>
        <td>
          22636
          -
          22723
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.FlatMap.Ops.flatTap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          cats.syntax.`package`.all.toFlatMapOps[F, fs2.io.file.Path](oldAcc.file.fold[F[fs2.io.file.Path]](createFile)(((x: fs2.io.file.Path) =&gt; F.pure[fs2.io.file.Path](x))))(F).flatTap[Unit](((x$27: fs2.io.file.Path) =&gt; append(x$27, newBytes)))
        </td>
      </tr><tr>
        <td>
          674
        </td>
        <td>
          14860
        </td>
        <td>
          22769
          -
          22781
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Stream.empty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.empty
        </td>
      </tr><tr>
        <td>
          674
        </td>
        <td>
          21666
        </td>
        <td>
          22783
          -
          22784
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          674
        </td>
        <td>
          19244
        </td>
        <td>
          22754
          -
          22767
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[fs2.io.file.Path](newFile)
        </td>
      </tr><tr>
        <td>
          674
        </td>
        <td>
          22442
        </td>
        <td>
          22636
          -
          22786
        </td>
        <td>
          Block
        </td>
        <td>
          cats.Functor.Ops.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          cats.syntax.`package`.all.toFunctorOps[F, fs2.io.file.Path](cats.syntax.`package`.all.toFlatMapOps[F, fs2.io.file.Path](oldAcc.file.fold[F[fs2.io.file.Path]](createFile)(((x: fs2.io.file.Path) =&gt; F.pure[fs2.io.file.Path](x))))(F).flatTap[Unit](((x$27: fs2.io.file.Path) =&gt; append(x$27, newBytes))))(F).map[Acc](((newFile: fs2.io.file.Path) =&gt; Acc.apply(scala.Some.apply[fs2.io.file.Path](newFile), fs2.Stream.empty, 0)))
        </td>
      </tr><tr>
        <td>
          674
        </td>
        <td>
          13554
        </td>
        <td>
          22636
          -
          22786
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.Functor.Ops.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          cats.syntax.`package`.all.toFunctorOps[F, fs2.io.file.Path](cats.syntax.`package`.all.toFlatMapOps[F, fs2.io.file.Path](oldAcc.file.fold[F[fs2.io.file.Path]](createFile)(((x: fs2.io.file.Path) =&gt; F.pure[fs2.io.file.Path](x))))(F).flatTap[Unit](((x$27: fs2.io.file.Path) =&gt; append(x$27, newBytes))))(F).map[Acc](((newFile: fs2.io.file.Path) =&gt; Acc.apply(scala.Some.apply[fs2.io.file.Path](newFile), fs2.Stream.empty, 0)))
        </td>
      </tr><tr>
        <td>
          674
        </td>
        <td>
          17594
        </td>
        <td>
          22750
          -
          22785
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.Acc.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Acc.apply(scala.Some.apply[fs2.io.file.Path](newFile), fs2.Stream.empty, 0)
        </td>
      </tr><tr>
        <td>
          675
        </td>
        <td>
          18098
        </td>
        <td>
          22811
          -
          22822
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.multipart.MultipartParser.Acc.file
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          oldAcc.file
        </td>
      </tr><tr>
        <td>
          675
        </td>
        <td>
          16788
        </td>
        <td>
          22800
          -
          22843
        </td>
        <td>
          Block
        </td>
        <td>
          cats.Applicative.pure
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          F.pure[Acc](Acc.apply(oldAcc.file, newBytes, newSize))
        </td>
      </tr><tr>
        <td>
          675
        </td>
        <td>
          14604
        </td>
        <td>
          22807
          -
          22842
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.Acc.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Acc.apply(oldAcc.file, newBytes, newSize)
        </td>
      </tr><tr>
        <td>
          675
        </td>
        <td>
          20809
        </td>
        <td>
          22800
          -
          22843
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.Applicative.pure
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          F.pure[Acc](Acc.apply(oldAcc.file, newBytes, newSize))
        </td>
      </tr><tr>
        <td>
          679
        </td>
        <td>
          15378
        </td>
        <td>
          22936
          -
          22949
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.Applicative.pure
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          F.pure[fs2.Stream[F,Byte]](bytes)
        </td>
      </tr><tr>
        <td>
          682
        </td>
        <td>
          21685
        </td>
        <td>
          23001
          -
          23047
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          cats.syntax.ApplicativeOps.whenA
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          cats.syntax.`package`.all.catsSyntaxApplicative[F, Unit](append(file, bytes)).whenA(size.&gt;(0))(F)
        </td>
      </tr><tr>
        <td>
          683
        </td>
        <td>
          22465
        </td>
        <td>
          23001
          -
          23141
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.Functor.Ops.as
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          cats.syntax.`package`.all.toFunctorOps[F, Unit](cats.syntax.`package`.all.catsSyntaxApplicative[F, Unit](append(file, bytes)).whenA(size.&gt;(0))(F))(F).as[fs2.Stream[F,Byte]](files.readAll(file, chunkSize, fs2.io.file.Flags.Read))
        </td>
      </tr><tr>
        <td>
          684
        </td>
        <td>
          14073
        </td>
        <td>
          23075
          -
          23129
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.io.file.Files.readAll
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          files.readAll(file, chunkSize, fs2.io.file.Flags.Read)
        </td>
      </tr><tr>
        <td>
          684
        </td>
        <td>
          17833
        </td>
        <td>
          23118
          -
          23128
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.io.file.Flags.Read
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.io.file.Flags.Read
        </td>
      </tr><tr>
        <td>
          690
        </td>
        <td>
          20907
        </td>
        <td>
          23333
          -
          23334
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          690
        </td>
        <td>
          18325
        </td>
        <td>
          23313
          -
          23317
        </td>
        <td>
          Select
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.None
        </td>
      </tr><tr>
        <td>
          690
        </td>
        <td>
          17304
        </td>
        <td>
          23309
          -
          23335
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.Acc.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Acc.apply(scala.None, fs2.Stream.empty, 0)
        </td>
      </tr><tr>
        <td>
          690
        </td>
        <td>
          14621
        </td>
        <td>
          23319
          -
          23331
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Stream.empty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.empty
        </td>
      </tr><tr>
        <td>
          691
        </td>
        <td>
          13801
        </td>
        <td>
          23351
          -
          23382
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Some[(org.http4s.Headers, Acc)], None.type](scala.Some.apply[(org.http4s.Headers, Acc)](scala.Tuple2.apply[org.http4s.Headers, Acc](headers, newAcc)), scala.None)
        </td>
      </tr><tr>
        <td>
          691
        </td>
        <td>
          15398
        </td>
        <td>
          23357
          -
          23374
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[org.http4s.Headers, Acc](headers, newAcc)
        </td>
      </tr><tr>
        <td>
          691
        </td>
        <td>
          22320
        </td>
        <td>
          23344
          -
          23383
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.Applicative.pure
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          F.pure[(Option[(org.http4s.Headers, Acc)], Option[org.http4s.multipart.Part[F]])](scala.Tuple2.apply[Some[(org.http4s.Headers, Acc)], None.type](scala.Some.apply[(org.http4s.Headers, Acc)](scala.Tuple2.apply[org.http4s.Headers, Acc](headers, newAcc)), scala.None))
        </td>
      </tr><tr>
        <td>
          691
        </td>
        <td>
          21551
        </td>
        <td>
          23352
          -
          23375
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[(org.http4s.Headers, Acc)](scala.Tuple2.apply[org.http4s.Headers, Acc](headers, newAcc))
        </td>
      </tr><tr>
        <td>
          691
        </td>
        <td>
          17851
        </td>
        <td>
          23377
          -
          23381
        </td>
        <td>
          Select
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.None
        </td>
      </tr><tr>
        <td>
          694
        </td>
        <td>
          18341
        </td>
        <td>
          23521
          -
          23545
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.internal.bug
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.http4s.internal.`package`.bug(&quot;Missing PartStart&quot;)
        </td>
      </tr><tr>
        <td>
          694
        </td>
        <td>
          14639
        </td>
        <td>
          23508
          -
          23546
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.ApplicativeError.raiseError
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          F.raiseError[(Option[(org.http4s.Headers, Acc)], Option[org.http4s.multipart.Part[F]])](org.http4s.internal.`package`.bug(&quot;Missing PartStart&quot;))
        </td>
      </tr><tr>
        <td>
          696
        </td>
        <td>
          13690
        </td>
        <td>
          23613
          -
          23709
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.Functor.Ops.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          cats.syntax.`package`.all.toFunctorOps[F, Acc](stepPartChunk(oldAcc, chunk))(F).map[(Option[(org.http4s.Headers, Acc)], Option[org.http4s.multipart.Part[F]])](((newAcc: Acc) =&gt; scala.Tuple2.apply[Some[(org.http4s.Headers, Acc)], None.type](scala.Some.apply[(org.http4s.Headers, Acc)](scala.Tuple2.apply[org.http4s.Headers, Acc](headers, newAcc)), scala.None)))
        </td>
      </tr><tr>
        <td>
          696
        </td>
        <td>
          20779
        </td>
        <td>
          23613
          -
          23641
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.stepPartChunk
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          stepPartChunk(oldAcc, chunk)
        </td>
      </tr><tr>
        <td>
          697
        </td>
        <td>
          21571
        </td>
        <td>
          23694
          -
          23698
        </td>
        <td>
          Select
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.None
        </td>
      </tr><tr>
        <td>
          697
        </td>
        <td>
          17013
        </td>
        <td>
          23674
          -
          23691
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[org.http4s.Headers, Acc](headers, newAcc)
        </td>
      </tr><tr>
        <td>
          697
        </td>
        <td>
          14988
        </td>
        <td>
          23669
          -
          23692
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[(org.http4s.Headers, Acc)](scala.Tuple2.apply[org.http4s.Headers, Acc](headers, newAcc))
        </td>
      </tr><tr>
        <td>
          697
        </td>
        <td>
          17586
        </td>
        <td>
          23668
          -
          23699
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Some[(org.http4s.Headers, Acc)], None.type](scala.Some.apply[(org.http4s.Headers, Acc)](scala.Tuple2.apply[org.http4s.Headers, Acc](headers, newAcc)), scala.None)
        </td>
      </tr><tr>
        <td>
          701
        </td>
        <td>
          20226
        </td>
        <td>
          23811
          -
          23827
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Function1.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          stepPartEnd.apply(acc)
        </td>
      </tr><tr>
        <td>
          702
        </td>
        <td>
          15374
        </td>
        <td>
          23811
          -
          23885
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.Functor.Ops.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          cats.syntax.`package`.all.toFunctorOps[F, fs2.Stream[F,Byte]](stepPartEnd.apply(acc))(F).map[(Option[(org.http4s.Headers, Acc)], Option[org.http4s.multipart.Part[F]])](((body: fs2.Stream[F,Byte]) =&gt; scala.Tuple2.apply[None.type, Some[org.http4s.multipart.Part[[_]F[_]]]](scala.None, scala.Some.apply[org.http4s.multipart.Part[[_]F[_]]](Part.apply[[_]F[_]](headers, body)))))
        </td>
      </tr><tr>
        <td>
          702
        </td>
        <td>
          18223
        </td>
        <td>
          23852
          -
          23856
        </td>
        <td>
          Select
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.None
        </td>
      </tr><tr>
        <td>
          702
        </td>
        <td>
          14509
        </td>
        <td>
          23863
          -
          23882
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.Part.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Part.apply[[_]F[_]](headers, body)
        </td>
      </tr><tr>
        <td>
          702
        </td>
        <td>
          20801
        </td>
        <td>
          23858
          -
          23883
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[org.http4s.multipart.Part[[_]F[_]]](Part.apply[[_]F[_]](headers, body))
        </td>
      </tr><tr>
        <td>
          702
        </td>
        <td>
          16910
        </td>
        <td>
          23851
          -
          23884
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[None.type, Some[org.http4s.multipart.Part[[_]F[_]]]](scala.None, scala.Some.apply[org.http4s.multipart.Part[[_]F[_]]](Part.apply[[_]F[_]](headers, body)))
        </td>
      </tr><tr>
        <td>
          705
        </td>
        <td>
          21589
        </td>
        <td>
          24016
          -
          24038
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.internal.bug
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.http4s.internal.`package`.bug(&quot;Missing PartEnd&quot;)
        </td>
      </tr><tr>
        <td>
          705
        </td>
        <td>
          17454
        </td>
        <td>
          24003
          -
          24039
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.ApplicativeError.raiseError
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          F.raiseError[(Option[(org.http4s.Headers, Acc)], Option[org.http4s.multipart.Part[F]])](org.http4s.internal.`package`.bug(&quot;Missing PartEnd&quot;))
        </td>
      </tr><tr>
        <td>
          712
        </td>
        <td>
          13710
        </td>
        <td>
          24051
          -
          24203
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.evalMapAccumulate
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          x$28.through[[x]F[x], org.http4s.multipart.MultipartParser.Event](MultipartParser.this.parseEvents[[_]F[_]](boundary, limit)(F)).through[[x]F[x], org.http4s.multipart.MultipartParser.Event](MultipartParser.this.limitParts[[x]F[x]](maxParts, failOnLimit)(fs2.this.RaiseThrowable.fromApplicativeError[[x]F[x]](F))).evalMapAccumulate[[x]F[x], Option[(org.http4s.Headers, Acc)], Option[org.http4s.multipart.Part[F]]](cats.syntax.`package`.all.none[(org.http4s.Headers, Acc)])(step)
        </td>
      </tr><tr>
        <td>
          712
        </td>
        <td>
          20501
        </td>
        <td>
          24197
          -
          24197
        </td>
        <td>
          TypeApply
        </td>
        <td>
          fs2.Stream.functorFilterInstance
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Stream.functorFilterInstance[[x]F[x]]
        </td>
      </tr><tr>
        <td>
          713
        </td>
        <td>
          14232
        </td>
        <td>
          24051
          -
          24226
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.FunctorFilter.Ops.mapFilter
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          cats.syntax.`package`.all.toFunctorFilterOps[[+O]fs2.Stream[[x]F[x],O], (Option[(org.http4s.Headers, Acc)], Option[org.http4s.multipart.Part[F]])](x$28.through[[x]F[x], org.http4s.multipart.MultipartParser.Event](MultipartParser.this.parseEvents[[_]F[_]](boundary, limit)(F)).through[[x]F[x], org.http4s.multipart.MultipartParser.Event](MultipartParser.this.limitParts[[x]F[x]](maxParts, failOnLimit)(fs2.this.RaiseThrowable.fromApplicativeError[[x]F[x]](F))).evalMapAccumulate[[x]F[x], Option[(org.http4s.Headers, Acc)], Option[org.http4s.multipart.Part[F]]](cats.syntax.`package`.all.none[(org.http4s.Headers, Acc)])(step))(fs2.this.Stream.functorFilterInstance[[x]F[x]]).mapFilter[org.http4s.multipart.Part[F]](((x$29: (Option[(org.http4s.Headers, Acc)], Option[org.http4s.multipart.Part[F]])) =&gt; x$29._2))
        </td>
      </tr><tr>
        <td>
          713
        </td>
        <td>
          18623
        </td>
        <td>
          24221
          -
          24225
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$29._2
        </td>
      </tr><tr>
        <td>
          722
        </td>
        <td>
          13582
        </td>
        <td>
          24579
          -
          24970
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.FlatMap.Ops.flatMap
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          cats.syntax.`package`.all.toFlatMapOps[F, cats.effect.kernel.Deferred[F,Either[Throwable,A]]](F.deferred[Either[Throwable,A]])(F).flatMap[A](((deferred: cats.effect.kernel.Deferred[F,Either[Throwable,A]]) =&gt; cats.syntax.`package`.all.catsSyntaxApply[F, cats.effect.kernel.Fiber[F,Throwable,Nothing]](supervisor.supervise[Nothing](cats.syntax.`package`.all.catsSyntaxMonadErrorRethrow[[+A]cats.effect.kernel.Resource[F,A], Throwable, A](resource.attempt[Throwable](F).evalTap[Boolean](((a: Either[Throwable,A]) =&gt; deferred.complete(a))))(kernel.this.Resource.catsEffectConcurrentForResource[[_]F[_]](F)).rethrow(kernel.this.Resource.catsEffectConcurrentForResource[[_]F[_]](F)).useForever(F)))(F).*&gt;[A](cats.syntax.`package`.all.catsSyntaxMonadErrorRethrow[F, Throwable, A](deferred.get)(F).rethrow(F))))
        </td>
      </tr><tr>
        <td>
          722
        </td>
        <td>
          20665
        </td>
        <td>
          24579
          -
          24611
        </td>
        <td>
          TypeApply
        </td>
        <td>
          cats.effect.kernel.GenConcurrent.deferred
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          F.deferred[Either[Throwable,A]]
        </td>
      </tr><tr>
        <td>
          723
        </td>
        <td>
          15229
        </td>
        <td>
          24640
          -
          24940
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.effect.std.Supervisor.supervise
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          supervisor.supervise[Nothing](cats.syntax.`package`.all.catsSyntaxMonadErrorRethrow[[+A]cats.effect.kernel.Resource[F,A], Throwable, A](resource.attempt[Throwable](F).evalTap[Boolean](((a: Either[Throwable,A]) =&gt; deferred.complete(a))))(kernel.this.Resource.catsEffectConcurrentForResource[[_]F[_]](F)).rethrow(kernel.this.Resource.catsEffectConcurrentForResource[[_]F[_]](F)).useForever(F))
        </td>
      </tr><tr>
        <td>
          729
        </td>
        <td>
          16928
        </td>
        <td>
          24679
          -
          24932
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          cats.effect.kernel.Resource.useForever
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          cats.syntax.`package`.all.catsSyntaxMonadErrorRethrow[[+A]cats.effect.kernel.Resource[F,A], Throwable, A](resource.attempt[Throwable](F).evalTap[Boolean](((a: Either[Throwable,A]) =&gt; deferred.complete(a))))(kernel.this.Resource.catsEffectConcurrentForResource[[_]F[_]](F)).rethrow(kernel.this.Resource.catsEffectConcurrentForResource[[_]F[_]](F)).useForever(F)
        </td>
      </tr><tr>
        <td>
          730
        </td>
        <td>
          21828
        </td>
        <td>
          24944
          -
          24964
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          cats.syntax.MonadErrorRethrowOps.rethrow
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          cats.syntax.`package`.all.catsSyntaxMonadErrorRethrow[F, Throwable, A](deferred.get)(F).rethrow(F)
        </td>
      </tr><tr>
        <td>
          730
        </td>
        <td>
          17468
        </td>
        <td>
          24640
          -
          24964
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.Apply.Ops.*&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          cats.syntax.`package`.all.catsSyntaxApply[F, cats.effect.kernel.Fiber[F,Throwable,Nothing]](supervisor.supervise[Nothing](cats.syntax.`package`.all.catsSyntaxMonadErrorRethrow[[+A]cats.effect.kernel.Resource[F,A], Throwable, A](resource.attempt[Throwable](F).evalTap[Boolean](((a: Either[Throwable,A]) =&gt; deferred.complete(a))))(kernel.this.Resource.catsEffectConcurrentForResource[[_]F[_]](F)).rethrow(kernel.this.Resource.catsEffectConcurrentForResource[[_]F[_]](F)).useForever(F)))(F).*&gt;[A](cats.syntax.`package`.all.catsSyntaxMonadErrorRethrow[F, Throwable, A](deferred.get)(F).rethrow(F))
        </td>
      </tr><tr>
        <td>
          750
        </td>
        <td>
          20523
        </td>
        <td>
          25502
          -
          25543
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          org.http4s.multipart.MultipartParser.pullPartsEvents
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.pullPartsEvents[[_]F[_]](boundary, x$31, headerLimit)(evidence$13)
        </td>
      </tr><tr>
        <td>
          750
        </td>
        <td>
          18643
        </td>
        <td>
          25462
          -
          25544
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.skipPrelude[[_]F[_]](boundary, x$30)(evidence$13).flatMap[[x]F[x], org.http4s.multipart.MultipartParser.Event, Unit](((x$31: fs2.Stream[[_]F[_],Byte]) =&gt; MultipartParser.this.pullPartsEvents[[_]F[_]](boundary, x$31, headerLimit)(evidence$13)))
        </td>
      </tr><tr>
        <td>
          751
        </td>
        <td>
          14480
        </td>
        <td>
          25462
          -
          25558
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Pull.StreamPullOps.stream
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Pull.StreamPullOps[[x]F[x], org.http4s.multipart.MultipartParser.Event](MultipartParser.this.skipPrelude[[_]F[_]](boundary, x$30)(evidence$13).flatMap[[x]F[x], org.http4s.multipart.MultipartParser.Event, Unit](((x$31: fs2.Stream[[_]F[_],Byte]) =&gt; MultipartParser.this.pullPartsEvents[[_]F[_]](boundary, x$31, headerLimit)(evidence$13)))).stream
        </td>
      </tr><tr>
        <td>
          760
        </td>
        <td>
          20685
        </td>
        <td>
          25844
          -
          25869
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Function1.apply
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.StartLineBytesN.apply(boundary)
        </td>
      </tr><tr>
        <td>
          763
        </td>
        <td>
          16703
        </td>
        <td>
          25957
          -
          26318
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Stream.InvariantOps[[_]F[_], Byte](s).pull.uncons.flatMap[[x]F[x], fs2.INothing, fs2.Stream[F,Byte]](((x0$1: Option[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]) =&gt; x0$1 match {
  case (value: (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])): Some[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]((_1: fs2.Chunk[Byte], _2: fs2.Stream[[_]F[_],Byte]): (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])((chnk @ _), (rest @ _))) =&gt; {
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$32: (Int, fs2.Stream[Nothing,Byte]) = (MultipartParser.this.splitAndIgnorePrev[Nothing](dashBoundaryBytes, state, chnk): (Int, fs2.Stream[Nothing,Byte]) @unchecked) match {
      case (_1: Int, _2: fs2.Stream[Nothing,Byte]): (Int, fs2.Stream[Nothing,Byte])((ix @ _), (remainder @ _)) =&gt; scala.Tuple2.apply[Int, fs2.Stream[Nothing,Byte]](ix, remainder)
    };
    val ix: Int = x$32._1;
    val remainder: fs2.Stream[Nothing,Byte] = x$32._2;
    if (cats.syntax.`package`.all.catsSyntaxEq[Int](ix)(kernel.this.Eq.catsKernelInstancesForInt).===(dashBoundaryBytes.length))
      fs2.Pull.pure[Nothing, fs2.Stream[[_]F[_],Byte]](remainder.++[[_]F[_], Byte](rest))
    else
      go(rest, ix)
  }
  case scala.None =&gt; fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply(&quot;Malformed Malformed match&quot;, MalformedMessageBodyFailure.apply$default$2))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$14))
}))
        </td>
      </tr><tr>
        <td>
          765
        </td>
        <td>
          17164
        </td>
        <td>
          26031
          -
          26031
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$32._1
        </td>
      </tr><tr>
        <td>
          765
        </td>
        <td>
          13449
        </td>
        <td>
          26035
          -
          26035
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$32._2
        </td>
      </tr><tr>
        <td>
          766
        </td>
        <td>
          20539
        </td>
        <td>
          26156
          -
          26173
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          remainder.++[[_]F[_], Byte](rest)
        </td>
      </tr><tr>
        <td>
          766
        </td>
        <td>
          18508
        </td>
        <td>
          26146
          -
          26174
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.pure
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.pure[Nothing, fs2.Stream[[_]F[_],Byte]](remainder.++[[_]F[_], Byte](rest))
        </td>
      </tr><tr>
        <td>
          766
        </td>
        <td>
          21847
        </td>
        <td>
          26113
          -
          26113
        </td>
        <td>
          Select
        </td>
        <td>
          cats.kernel.Eq.catsKernelInstancesForInt
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          kernel.this.Eq.catsKernelInstancesForInt
        </td>
      </tr><tr>
        <td>
          766
        </td>
        <td>
          14505
        </td>
        <td>
          26146
          -
          26174
        </td>
        <td>
          Block
        </td>
        <td>
          fs2.Pull.pure
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.pure[Nothing, fs2.Stream[[_]F[_],Byte]](remainder.++[[_]F[_], Byte](rest))
        </td>
      </tr><tr>
        <td>
          766
        </td>
        <td>
          17725
        </td>
        <td>
          26120
          -
          26144
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Array.length
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          dashBoundaryBytes.length
        </td>
      </tr><tr>
        <td>
          766
        </td>
        <td>
          13601
        </td>
        <td>
          26113
          -
          26144
        </td>
        <td>
          Apply
        </td>
        <td>
          cats.syntax.EqOps.===
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          cats.syntax.`package`.all.catsSyntaxEq[Int](ix)(kernel.this.Eq.catsKernelInstancesForInt).===(dashBoundaryBytes.length)
        </td>
      </tr><tr>
        <td>
          767
        </td>
        <td>
          17179
        </td>
        <td>
          26190
          -
          26202
        </td>
        <td>
          Block
        </td>
        <td>
          org.http4s.multipart.MultipartParser.go
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          go(rest, ix)
        </td>
      </tr><tr>
        <td>
          767
        </td>
        <td>
          20922
        </td>
        <td>
          26190
          -
          26202
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.go
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          go(rest, ix)
        </td>
      </tr><tr>
        <td>
          769
        </td>
        <td>
          13463
        </td>
        <td>
          26281
          -
          26308
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          &quot;Malformed Malformed match&quot;
        </td>
      </tr><tr>
        <td>
          769
        </td>
        <td>
          13553
        </td>
        <td>
          26252
          -
          26252
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.RaiseThrowable.fromApplicativeError
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$14)
        </td>
      </tr><tr>
        <td>
          769
        </td>
        <td>
          20413
        </td>
        <td>
          26234
          -
          26310
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.Pull.raiseError
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply(&quot;Malformed Malformed match&quot;, MalformedMessageBodyFailure.apply$default$2))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$14))
        </td>
      </tr><tr>
        <td>
          769
        </td>
        <td>
          17745
        </td>
        <td>
          26253
          -
          26309
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.MalformedMessageBodyFailure.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          MalformedMessageBodyFailure.apply(&quot;Malformed Malformed match&quot;, MalformedMessageBodyFailure.apply$default$2)
        </td>
      </tr><tr>
        <td>
          769
        </td>
        <td>
          21425
        </td>
        <td>
          26253
          -
          26253
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.MalformedMessageBodyFailure.apply$default$2
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          MalformedMessageBodyFailure.apply$default$2
        </td>
      </tr><tr>
        <td>
          772
        </td>
        <td>
          14362
        </td>
        <td>
          26324
          -
          26337
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.go
        </td>
        <td>
          org.http4s.multipart.multipartsuite
        </td>
        <td style="background: #AEF1AE">
          go(stream, 0)
        </td>
      </tr><tr>
        <td>
          781
        </td>
        <td>
          20940
        </td>
        <td>
          26599
          -
          26623
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Function1.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.ExpectedBytesN.apply(boundary)
        </td>
      </tr><tr>
        <td>
          786
        </td>
        <td>
          13339
        </td>
        <td>
          26803
          -
          26851
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Function2.tupled
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((x$33: fs2.Stream[F,Byte], x$34: fs2.Stream[F,Byte]) =&gt; MultipartParser.this.pullPartEvents[F](x$33, x$34, delimiterBytes)(evidence$15)).tupled
        </td>
      </tr><tr>
        <td>
          786
        </td>
        <td>
          16922
        </td>
        <td>
          26804
          -
          26843
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          org.http4s.multipart.MultipartParser.pullPartEvents
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.pullPartEvents[F](x$33, x$34, delimiterBytes)(evidence$15)
        </td>
      </tr><tr>
        <td>
          788
        </td>
        <td>
          17614
        </td>
        <td>
          26873
          -
          26873
        </td>
        <td>
          TypeApply
        </td>
        <td>
          fs2.PullLowPriority.monadErrorInstance
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Pull.monadErrorInstance[[_]F[_], Nothing]
        </td>
      </tr><tr>
        <td>
          788
        </td>
        <td>
          21450
        </td>
        <td>
          26857
          -
          26912
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          org.http4s.multipart.MultipartParser.splitOrFinish
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.splitOrFinish[F](MultipartParser.this.DoubleCRLFBytesN, stream, headerLimit)(evidence$15)
        </td>
      </tr><tr>
        <td>
          790
        </td>
        <td>
          20129
        </td>
        <td>
          26968
          -
          26968
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.MalformedMessageBodyFailure.apply$default$2
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          MalformedMessageBodyFailure.apply$default$2
        </td>
      </tr><tr>
        <td>
          790
        </td>
        <td>
          16300
        </td>
        <td>
          26968
          -
          27024
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.MalformedMessageBodyFailure.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          MalformedMessageBodyFailure.apply(&quot;Cannot parse empty stream&quot;, MalformedMessageBodyFailure.apply$default$2)
        </td>
      </tr><tr>
        <td>
          790
        </td>
        <td>
          16805
        </td>
        <td>
          27026
          -
          27026
        </td>
        <td>
          TypeApply
        </td>
        <td>
          fs2.PullLowPriority.monadErrorInstance
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Pull.monadErrorInstance[[_]F[_], Nothing]
        </td>
      </tr><tr>
        <td>
          790
        </td>
        <td>
          13572
        </td>
        <td>
          26996
          -
          27023
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          &quot;Cannot parse empty stream&quot;
        </td>
      </tr><tr>
        <td>
          793
        </td>
        <td>
          14384
        </td>
        <td>
          27195
          -
          27206
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.multipart.MultipartParser.streamEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.streamEmpty
        </td>
      </tr><tr>
        <td>
          793
        </td>
        <td>
          21172
        </td>
        <td>
          27187
          -
          27206
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.!=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          rest.!=(MultipartParser.this.streamEmpty)
        </td>
      </tr><tr>
        <td>
          795
        </td>
        <td>
          14249
        </td>
        <td>
          26857
          -
          27497
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          cats.syntax.`package`.all.catsSyntaxMonadError[[+R]fs2.Pull[F,Nothing,R], Throwable, (fs2.Stream[F,Byte], fs2.Stream[F,Byte])](MultipartParser.this.splitOrFinish[F](MultipartParser.this.DoubleCRLFBytesN, stream, headerLimit)(evidence$15))(fs2.this.Pull.monadErrorInstance[[_]F[_], Nothing]).ensure(MalformedMessageBodyFailure.apply(&quot;Cannot parse empty stream&quot;, MalformedMessageBodyFailure.apply$default$2))(((x0$1: (fs2.Stream[F,Byte], fs2.Stream[F,Byte])) =&gt; x0$1 match {
  case (_1: fs2.Stream[[_]F[_],Byte], _2: fs2.Stream[[_]F[_],Byte]): (fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte])(_, (rest @ _)) =&gt; rest.!=(MultipartParser.this.streamEmpty)
}))(fs2.this.Pull.monadErrorInstance[[_]F[_], Nothing]).flatMap[[x]F[x], org.http4s.multipart.MultipartParser.Event, Unit](((x$35: (fs2.Stream[F,Byte], fs2.Stream[F,Byte])) =&gt; cats.syntax.`package`.all.catsSyntaxMonadIdOps[(fs2.Stream[F,Byte], fs2.Stream[F,Byte])](x$35).iterateWhileM[[+R]fs2.Pull[[x]F[x],org.http4s.multipart.MultipartParser.Event,R]](((acc: (fs2.Stream[F,Byte], fs2.Stream[F,Byte])) =&gt; pullPartEvents0.apply(acc).flatMap[[x]F[x], org.http4s.multipart.MultipartParser.Event, (fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte])](((x$36: fs2.Stream[F,Byte]) =&gt; MultipartParser.this.splitOrFinish[[_]F[_]](MultipartParser.this.DoubleCRLFBytesN, x$36, headerLimit)(evidence$15)))))(((x0$2: (fs2.Stream[F,Byte], fs2.Stream[F,Byte])) =&gt; x0$2 match {
  case (_1: fs2.Stream[[_]F[_],Byte], _2: fs2.Stream[[_]F[_],Byte]): (fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte])(_, (rest @ _)) =&gt; rest.!=(MultipartParser.this.streamEmpty)
}))(fs2.this.Pull.monadErrorInstance[[x]F[x], org.http4s.multipart.MultipartParser.Event]).void))
        </td>
      </tr><tr>
        <td>
          797
        </td>
        <td>
          21334
        </td>
        <td>
          27274
          -
          27432
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          pullPartEvents0.apply(acc).flatMap[[x]F[x], org.http4s.multipart.MultipartParser.Event, (fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte])](((x$36: fs2.Stream[F,Byte]) =&gt; MultipartParser.this.splitOrFinish[[_]F[_]](MultipartParser.this.DoubleCRLFBytesN, x$36, headerLimit)(evidence$15)))
        </td>
      </tr><tr>
        <td>
          798
        </td>
        <td>
          13026
        </td>
        <td>
          27316
          -
          27420
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          org.http4s.multipart.MultipartParser.splitOrFinish
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.splitOrFinish[[_]F[_]](MultipartParser.this.DoubleCRLFBytesN, x$36, headerLimit)(evidence$15)
        </td>
      </tr><tr>
        <td>
          804
        </td>
        <td>
          16687
        </td>
        <td>
          27239
          -
          27489
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Pull.void
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          cats.syntax.`package`.all.catsSyntaxMonadIdOps[(fs2.Stream[F,Byte], fs2.Stream[F,Byte])](x$35).iterateWhileM[[+R]fs2.Pull[[x]F[x],org.http4s.multipart.MultipartParser.Event,R]](((acc: (fs2.Stream[F,Byte], fs2.Stream[F,Byte])) =&gt; pullPartEvents0.apply(acc).flatMap[[x]F[x], org.http4s.multipart.MultipartParser.Event, (fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte])](((x$36: fs2.Stream[F,Byte]) =&gt; MultipartParser.this.splitOrFinish[[_]F[_]](MultipartParser.this.DoubleCRLFBytesN, x$36, headerLimit)(evidence$15)))))(((x0$2: (fs2.Stream[F,Byte], fs2.Stream[F,Byte])) =&gt; x0$2 match {
  case (_1: fs2.Stream[[_]F[_],Byte], _2: fs2.Stream[[_]F[_],Byte]): (fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte])(_, (rest @ _)) =&gt; rest.!=(MultipartParser.this.streamEmpty)
}))(fs2.this.Pull.monadErrorInstance[[x]F[x], org.http4s.multipart.MultipartParser.Event]).void
        </td>
      </tr><tr>
        <td>
          804
        </td>
        <td>
          17634
        </td>
        <td>
          27471
          -
          27482
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.multipart.MultipartParser.streamEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.streamEmpty
        </td>
      </tr><tr>
        <td>
          804
        </td>
        <td>
          20020
        </td>
        <td>
          27443
          -
          27443
        </td>
        <td>
          TypeApply
        </td>
        <td>
          fs2.PullLowPriority.monadErrorInstance
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Pull.monadErrorInstance[[x]F[x], org.http4s.multipart.MultipartParser.Event]
        </td>
      </tr><tr>
        <td>
          804
        </td>
        <td>
          13592
        </td>
        <td>
          27463
          -
          27482
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.!=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          rest.!=(MultipartParser.this.streamEmpty)
        </td>
      </tr><tr>
        <td>
          815
        </td>
        <td>
          21190
        </td>
        <td>
          27764
          -
          27790
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          org.http4s.multipart.MultipartParser.parseHeaders
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.parseHeaders[[_]F[_]](headerStream)(evidence$16)
        </td>
      </tr><tr>
        <td>
          816
        </td>
        <td>
          13309
        </td>
        <td>
          27818
          -
          27857
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.output1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.output1[[x]fs2.Pure[x], org.http4s.multipart.MultipartParser.Event]((MultipartParser.this.PartStart.apply(headers): org.http4s.multipart.MultipartParser.Event))
        </td>
      </tr><tr>
        <td>
          816
        </td>
        <td>
          18019
        </td>
        <td>
          27806
          -
          27806
        </td>
        <td>
          TypeApply
        </td>
        <td>
          fs2.PullLowPriority.monadErrorInstance
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Pull.monadErrorInstance[[x]F[x], org.http4s.multipart.MultipartParser.Event]
        </td>
      </tr><tr>
        <td>
          816
        </td>
        <td>
          19909
        </td>
        <td>
          27747
          -
          27858
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.eval[F, org.http4s.Headers](MultipartParser.this.parseHeaders[[_]F[_]](headerStream)(evidence$16)).flatMap[[x]F[x], org.http4s.multipart.MultipartParser.Event, Unit](((headers: org.http4s.Headers) =&gt; fs2.Pull.output1[[x]fs2.Pure[x], org.http4s.multipart.MultipartParser.Event]((MultipartParser.this.PartStart.apply(headers): org.http4s.multipart.MultipartParser.Event))))
        </td>
      </tr><tr>
        <td>
          816
        </td>
        <td>
          16825
        </td>
        <td>
          27831
          -
          27849
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.PartStart.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.PartStart.apply(headers)
        </td>
      </tr><tr>
        <td>
          817
        </td>
        <td>
          14108
        </td>
        <td>
          27875
          -
          27911
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          org.http4s.multipart.MultipartParser.pullPartChunks
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.pullPartChunks[[_]F[_]](delimiterBytes, rest)(evidence$16)
        </td>
      </tr><tr>
        <td>
          818
        </td>
        <td>
          16587
        </td>
        <td>
          27747
          -
          28255
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          cats.syntax.`package`.all.catsSyntaxApply[[+R]fs2.Pull[[x]F[x],org.http4s.multipart.MultipartParser.Event,R], Unit](fs2.Pull.eval[F, org.http4s.Headers](MultipartParser.this.parseHeaders[[_]F[_]](headerStream)(evidence$16)).flatMap[[x]F[x], org.http4s.multipart.MultipartParser.Event, Unit](((headers: org.http4s.Headers) =&gt; fs2.Pull.output1[[x]fs2.Pure[x], org.http4s.multipart.MultipartParser.Event]((MultipartParser.this.PartStart.apply(headers): org.http4s.multipart.MultipartParser.Event)))))(fs2.this.Pull.monadErrorInstance[[x]F[x], org.http4s.multipart.MultipartParser.Event]).productR[fs2.Stream[[_]F[_],Byte]](MultipartParser.this.pullPartChunks[[_]F[_]](delimiterBytes, rest)(evidence$16)).flatMap[[x]F[x], org.http4s.multipart.MultipartParser.Event, fs2.Stream[F,Byte]](((x0$1: fs2.Stream[[_]F[_],Byte]) =&gt; x0$1 match {
  case (rest @ _) =&gt; if (rest.==(MultipartParser.this.streamEmpty))
    fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply(&quot;Part not terminated properly&quot;, MalformedMessageBodyFailure.apply$default$2))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$16))
  else
    fs2.Pull.output1[[x]fs2.Pure[x], org.http4s.multipart.MultipartParser.PartEnd.type](MultipartParser.this.PartEnd).as[fs2.Stream[[_]F[_],Byte]](rest)
}))
        </td>
      </tr><tr>
        <td>
          821
        </td>
        <td>
          20039
        </td>
        <td>
          28091
          -
          28102
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.multipart.MultipartParser.streamEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.streamEmpty
        </td>
      </tr><tr>
        <td>
          821
        </td>
        <td>
          16568
        </td>
        <td>
          28083
          -
          28102
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          rest.==(MultipartParser.this.streamEmpty)
        </td>
      </tr><tr>
        <td>
          822
        </td>
        <td>
          21208
        </td>
        <td>
          28133
          -
          28133
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.MalformedMessageBodyFailure.apply$default$2
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          MalformedMessageBodyFailure.apply$default$2
        </td>
      </tr><tr>
        <td>
          822
        </td>
        <td>
          17607
        </td>
        <td>
          28114
          -
          28193
        </td>
        <td>
          Block
        </td>
        <td>
          fs2.Pull.raiseError
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply(&quot;Part not terminated properly&quot;, MalformedMessageBodyFailure.apply$default$2))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$16))
        </td>
      </tr><tr>
        <td>
          822
        </td>
        <td>
          19808
        </td>
        <td>
          28114
          -
          28193
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.Pull.raiseError
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply(&quot;Part not terminated properly&quot;, MalformedMessageBodyFailure.apply$default$2))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$16))
        </td>
      </tr><tr>
        <td>
          822
        </td>
        <td>
          14661
        </td>
        <td>
          28161
          -
          28191
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          &quot;Part not terminated properly&quot;
        </td>
      </tr><tr>
        <td>
          822
        </td>
        <td>
          17337
        </td>
        <td>
          28133
          -
          28192
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.MalformedMessageBodyFailure.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          MalformedMessageBodyFailure.apply(&quot;Part not terminated properly&quot;, MalformedMessageBodyFailure.apply$default$2)
        </td>
      </tr><tr>
        <td>
          822
        </td>
        <td>
          13329
        </td>
        <td>
          28132
          -
          28132
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.RaiseThrowable.fromApplicativeError
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$16)
        </td>
      </tr><tr>
        <td>
          824
        </td>
        <td>
          14125
        </td>
        <td>
          28217
          -
          28247
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.as
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.output1[[x]fs2.Pure[x], org.http4s.multipart.MultipartParser.PartEnd.type](MultipartParser.this.PartEnd).as[fs2.Stream[[_]F[_],Byte]](rest)
        </td>
      </tr><tr>
        <td>
          824
        </td>
        <td>
          20282
        </td>
        <td>
          28217
          -
          28247
        </td>
        <td>
          Block
        </td>
        <td>
          fs2.Pull.as
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.output1[[x]fs2.Pure[x], org.http4s.multipart.MultipartParser.PartEnd.type](MultipartParser.this.PartEnd).as[fs2.Stream[[_]F[_],Byte]](rest)
        </td>
      </tr><tr>
        <td>
          837
        </td>
        <td>
          14679
        </td>
        <td>
          28670
          -
          28691
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Array.length
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          delimiterBytes.length
        </td>
      </tr><tr>
        <td>
          837
        </td>
        <td>
          20821
        </td>
        <td>
          28661
          -
          28691
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          state.==(delimiterBytes.length)
        </td>
      </tr><tr>
        <td>
          838
        </td>
        <td>
          13194
        </td>
        <td>
          28701
          -
          28721
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.pure
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.Pull.pure[Nothing, fs2.Stream[[x]F[x],Byte]](racc.++[[x]F[x], Byte](s))
        </td>
      </tr><tr>
        <td>
          838
        </td>
        <td>
          17359
        </td>
        <td>
          28711
          -
          28720
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.++
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          racc.++[[x]F[x], Byte](s)
        </td>
      </tr><tr>
        <td>
          838
        </td>
        <td>
          19823
        </td>
        <td>
          28701
          -
          28721
        </td>
        <td>
          Block
        </td>
        <td>
          fs2.Pull.pure
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          fs2.Pull.pure[Nothing, fs2.Stream[[x]F[x],Byte]](racc.++[[x]F[x], Byte](s))
        </td>
      </tr><tr>
        <td>
          840
        </td>
        <td>
          13968
        </td>
        <td>
          28741
          -
          29198
        </td>
        <td>
          Block
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Stream.InvariantOps[[_]F[_], Byte](s).pull.uncons.flatMap[[x]F[x], org.http4s.multipart.MultipartParser.PartChunk, fs2.Stream[F,Byte]](((x0$1: Option[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]) =&gt; x0$1 match {
  case (value: (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])): Some[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]((_1: fs2.Chunk[Byte], _2: fs2.Stream[[_]F[_],Byte]): (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])((chnk @ _), (rest @ _))) =&gt; {
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$37: (Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte]) = (MultipartParser.this.splitOnChunk[F](delimiterBytes, state, chnk, fs2.Stream.empty, racc): (Int, fs2.Stream[F,Byte], fs2.Stream[F,Byte]) @unchecked) match {
      case (_1: Int, _2: fs2.Stream[[_]F[_],Byte], _3: fs2.Stream[[_]F[_],Byte]): (Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte])((ix @ _), (l @ _), (r @ _)) =&gt; scala.Tuple3.apply[Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte]](ix, l, r)
    };
    val ix: Int = x$37._1;
    val l: fs2.Stream[[_]F[_],Byte] = x$37._2;
    val r: fs2.Stream[[_]F[_],Byte] = x$37._3;
    fs2.this.Stream.InvariantOps[[_]F[_], org.http4s.multipart.MultipartParser.PartChunk](l.chunks.map[org.http4s.multipart.MultipartParser.PartChunk](((x$38: fs2.Chunk[Byte]) =&gt; MultipartParser.this.PartChunk.apply(x$38)))).pull.echo.&gt;&gt;[[x]F[x], org.http4s.multipart.MultipartParser.PartChunk, fs2.Stream[F,Byte]](if (ix.==(delimiterBytes.length))
      fs2.Pull.pure[Nothing, fs2.Stream[[x]F[x],Byte]](r.++[[x]F[x], Byte](rest))
    else
      go(rest, ix, r))
  }
  case scala.None =&gt; fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply(&quot;Invalid boundary - partial boundary&quot;, MalformedMessageBodyFailure.apply$default$2))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$17))
}))
        </td>
      </tr><tr>
        <td>
          840
        </td>
        <td>
          15714
        </td>
        <td>
          28741
          -
          29198
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Stream.InvariantOps[[_]F[_], Byte](s).pull.uncons.flatMap[[x]F[x], org.http4s.multipart.MultipartParser.PartChunk, fs2.Stream[F,Byte]](((x0$1: Option[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]) =&gt; x0$1 match {
  case (value: (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])): Some[(fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])]((_1: fs2.Chunk[Byte], _2: fs2.Stream[[_]F[_],Byte]): (fs2.Chunk[Byte], fs2.Stream[[_]F[_],Byte])((chnk @ _), (rest @ _))) =&gt; {
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$37: (Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte]) = (MultipartParser.this.splitOnChunk[F](delimiterBytes, state, chnk, fs2.Stream.empty, racc): (Int, fs2.Stream[F,Byte], fs2.Stream[F,Byte]) @unchecked) match {
      case (_1: Int, _2: fs2.Stream[[_]F[_],Byte], _3: fs2.Stream[[_]F[_],Byte]): (Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte])((ix @ _), (l @ _), (r @ _)) =&gt; scala.Tuple3.apply[Int, fs2.Stream[[_]F[_],Byte], fs2.Stream[[_]F[_],Byte]](ix, l, r)
    };
    val ix: Int = x$37._1;
    val l: fs2.Stream[[_]F[_],Byte] = x$37._2;
    val r: fs2.Stream[[_]F[_],Byte] = x$37._3;
    fs2.this.Stream.InvariantOps[[_]F[_], org.http4s.multipart.MultipartParser.PartChunk](l.chunks.map[org.http4s.multipart.MultipartParser.PartChunk](((x$38: fs2.Chunk[Byte]) =&gt; MultipartParser.this.PartChunk.apply(x$38)))).pull.echo.&gt;&gt;[[x]F[x], org.http4s.multipart.MultipartParser.PartChunk, fs2.Stream[F,Byte]](if (ix.==(delimiterBytes.length))
      fs2.Pull.pure[Nothing, fs2.Stream[[x]F[x],Byte]](r.++[[x]F[x], Byte](rest))
    else
      go(rest, ix, r))
  }
  case scala.None =&gt; fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply(&quot;Invalid boundary - partial boundary&quot;, MalformedMessageBodyFailure.apply$default$2))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$17))
}))
        </td>
      </tr><tr>
        <td>
          842
        </td>
        <td>
          20293
        </td>
        <td>
          28826
          -
          28826
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple3._3
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$37._3
        </td>
      </tr><tr>
        <td>
          842
        </td>
        <td>
          17631
        </td>
        <td>
          28819
          -
          28819
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple3._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$37._1
        </td>
      </tr><tr>
        <td>
          842
        </td>
        <td>
          13725
        </td>
        <td>
          28823
          -
          28823
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple3._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$37._2
        </td>
      </tr><tr>
        <td>
          843
        </td>
        <td>
          16475
        </td>
        <td>
          28908
          -
          29066
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.&gt;&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.Stream.InvariantOps[[_]F[_], org.http4s.multipart.MultipartParser.PartChunk](l.chunks.map[org.http4s.multipart.MultipartParser.PartChunk](((x$38: fs2.Chunk[Byte]) =&gt; MultipartParser.this.PartChunk.apply(x$38)))).pull.echo.&gt;&gt;[[x]F[x], org.http4s.multipart.MultipartParser.PartChunk, fs2.Stream[F,Byte]](if (ix.==(delimiterBytes.length))
  fs2.Pull.pure[Nothing, fs2.Stream[[x]F[x],Byte]](r.++[[x]F[x], Byte](rest))
else
  go(rest, ix, r))
        </td>
      </tr><tr>
        <td>
          843
        </td>
        <td>
          22758
        </td>
        <td>
          28908
          -
          28934
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          l.chunks.map[org.http4s.multipart.MultipartParser.PartChunk](((x$38: fs2.Chunk[Byte]) =&gt; MultipartParser.this.PartChunk.apply(x$38)))
        </td>
      </tr><tr>
        <td>
          843
        </td>
        <td>
          16602
        </td>
        <td>
          28921
          -
          28933
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.PartChunk.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MultipartParser.this.PartChunk.apply(x$38)
        </td>
      </tr><tr>
        <td>
          844
        </td>
        <td>
          17312
        </td>
        <td>
          28968
          -
          28995
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ix.==(delimiterBytes.length)
        </td>
      </tr><tr>
        <td>
          844
        </td>
        <td>
          17485
        </td>
        <td>
          28997
          -
          29017
        </td>
        <td>
          Block
        </td>
        <td>
          fs2.Pull.pure
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.pure[Nothing, fs2.Stream[[x]F[x],Byte]](r.++[[x]F[x], Byte](rest))
        </td>
      </tr><tr>
        <td>
          844
        </td>
        <td>
          13210
        </td>
        <td>
          29007
          -
          29016
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Stream.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          r.++[[x]F[x], Byte](rest)
        </td>
      </tr><tr>
        <td>
          844
        </td>
        <td>
          20839
        </td>
        <td>
          28974
          -
          28995
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Array.length
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          delimiterBytes.length
        </td>
      </tr><tr>
        <td>
          844
        </td>
        <td>
          19840
        </td>
        <td>
          28997
          -
          29017
        </td>
        <td>
          Apply
        </td>
        <td>
          fs2.Pull.pure
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.pure[Nothing, fs2.Stream[[x]F[x],Byte]](r.++[[x]F[x], Byte](rest))
        </td>
      </tr><tr>
        <td>
          845
        </td>
        <td>
          13744
        </td>
        <td>
          29037
          -
          29052
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.go
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          go(rest, ix, r)
        </td>
      </tr><tr>
        <td>
          845
        </td>
        <td>
          20538
        </td>
        <td>
          29037
          -
          29052
        </td>
        <td>
          Block
        </td>
        <td>
          org.http4s.multipart.MultipartParser.go
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          go(rest, ix, r)
        </td>
      </tr><tr>
        <td>
          848
        </td>
        <td>
          12934
        </td>
        <td>
          29120
          -
          29120
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.RaiseThrowable.fromApplicativeError
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$17)
        </td>
      </tr><tr>
        <td>
          848
        </td>
        <td>
          20703
        </td>
        <td>
          29121
          -
          29121
        </td>
        <td>
          Select
        </td>
        <td>
          org.http4s.MalformedMessageBodyFailure.apply$default$2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MalformedMessageBodyFailure.apply$default$2
        </td>
      </tr><tr>
        <td>
          848
        </td>
        <td>
          17332
        </td>
        <td>
          29121
          -
          29187
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.MalformedMessageBodyFailure.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MalformedMessageBodyFailure.apply(&quot;Invalid boundary - partial boundary&quot;, MalformedMessageBodyFailure.apply$default$2)
        </td>
      </tr><tr>
        <td>
          848
        </td>
        <td>
          22777
        </td>
        <td>
          29149
          -
          29186
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          &quot;Invalid boundary - partial boundary&quot;
        </td>
      </tr><tr>
        <td>
          848
        </td>
        <td>
          19433
        </td>
        <td>
          29102
          -
          29188
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          fs2.Pull.raiseError
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Pull.raiseError[F](MalformedMessageBodyFailure.apply(&quot;Invalid boundary - partial boundary&quot;, MalformedMessageBodyFailure.apply$default$2))(fs2.this.RaiseThrowable.fromApplicativeError[[_]F[_]](evidence$17))
        </td>
      </tr><tr>
        <td>
          851
        </td>
        <td>
          22641
        </td>
        <td>
          29204
          -
          29231
        </td>
        <td>
          Apply
        </td>
        <td>
          org.http4s.multipart.MultipartParser.go
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          go(stream, 0, fs2.Stream.empty)
        </td>
      </tr><tr>
        <td>
          851
        </td>
        <td>
          16187
        </td>
        <td>
          29218
          -
          29230
        </td>
        <td>
          Select
        </td>
        <td>
          fs2.Stream.empty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          fs2.Stream.empty
        </td>
      </tr><tr>
        <td>
          851
        </td>
        <td>
          20559
        </td>
        <td>
          29215
          -
          29216
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr>
    </table>
          </div>
        </div>
      </body>
    </html>